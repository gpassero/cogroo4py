from jpype._jcollection import _JCollection
from jpype._jcollection import _JEnumeration
from jpype._jcollection import _JIterator
from jpype._jcollection import _JList
from jpype._jcollection import _JMap
from jpype._jcollection import _JMapEntry
from jpype._jcollection import _JSet
import java
import java.io
import java.lang
import java.math
import java.nio
import java.nio.channels
import java.nio.file
import java.security
import java.time
import java.util.concurrent
import java.util.function
import java.util.jar
import java.util.logging
import java.util.prefs
import java.util.regex
import java.util.spi
import java.util.stream
import java.util.zip
import jpype.protocol
import typing



class Arrays:
    _asList__T = typing.TypeVar('_asList__T')  # <T>
    @staticmethod
    def asList(tArray: typing.List[_asList__T]) -> 'List'[_asList__T]: ...
    _binarySearch_11__T = typing.TypeVar('_binarySearch_11__T')  # <T>
    _binarySearch_13__T = typing.TypeVar('_binarySearch_13__T')  # <T>
    @typing.overload
    @staticmethod
    def binarySearch(byteArray: typing.List[int], byte2: int) -> int: ...
    @typing.overload
    @staticmethod
    def binarySearch(byteArray: typing.List[int], int: int, int2: int, byte2: int) -> int: ...
    @typing.overload
    @staticmethod
    def binarySearch(charArray: typing.List[str], char2: str) -> int: ...
    @typing.overload
    @staticmethod
    def binarySearch(charArray: typing.List[str], int: int, int2: int, char2: str) -> int: ...
    @typing.overload
    @staticmethod
    def binarySearch(doubleArray: typing.List[float], double2: float) -> int: ...
    @typing.overload
    @staticmethod
    def binarySearch(doubleArray: typing.List[float], int: int, int2: int, double2: float) -> int: ...
    @typing.overload
    @staticmethod
    def binarySearch(floatArray: typing.List[float], float2: float) -> int: ...
    @typing.overload
    @staticmethod
    def binarySearch(floatArray: typing.List[float], int: int, int2: int, float2: float) -> int: ...
    @typing.overload
    @staticmethod
    def binarySearch(intArray: typing.List[int], int2: int) -> int: ...
    @typing.overload
    @staticmethod
    def binarySearch(intArray: typing.List[int], int2: int, int3: int, int4: int) -> int: ...
    @typing.overload
    @staticmethod
    def binarySearch(objectArray: typing.List[typing.Any], int: int, int2: int, object2: typing.Any) -> int: ...
    @typing.overload
    @staticmethod
    def binarySearch(tArray: typing.List[_binarySearch_11__T], int: int, int2: int, t2: _binarySearch_11__T, comparator: typing.Union['Comparator'[_binarySearch_11__T], typing.Callable[[_binarySearch_11__T, _binarySearch_11__T], int]]) -> int: ...
    @typing.overload
    @staticmethod
    def binarySearch(objectArray: typing.List[typing.Any], object2: typing.Any) -> int: ...
    @typing.overload
    @staticmethod
    def binarySearch(tArray: typing.List[_binarySearch_13__T], t2: _binarySearch_13__T, comparator: typing.Union['Comparator'[_binarySearch_13__T], typing.Callable[[_binarySearch_13__T, _binarySearch_13__T], int]]) -> int: ...
    @typing.overload
    @staticmethod
    def binarySearch(longArray: typing.List[int], int: int, int2: int, long2: int) -> int: ...
    @typing.overload
    @staticmethod
    def binarySearch(longArray: typing.List[int], long2: int) -> int: ...
    @typing.overload
    @staticmethod
    def binarySearch(shortArray: typing.List[int], int: int, int2: int, short2: int) -> int: ...
    @typing.overload
    @staticmethod
    def binarySearch(shortArray: typing.List[int], short2: int) -> int: ...
    _copyOf_6__T = typing.TypeVar('_copyOf_6__T')  # <T>
    _copyOf_7__T = typing.TypeVar('_copyOf_7__T')  # <T>
    _copyOf_7__U = typing.TypeVar('_copyOf_7__U')  # <U>
    @typing.overload
    @staticmethod
    def copyOf(booleanArray: typing.List[bool], int: int) -> typing.List[bool]: ...
    @typing.overload
    @staticmethod
    def copyOf(byteArray: typing.List[int], int: int) -> typing.List[int]: ...
    @typing.overload
    @staticmethod
    def copyOf(charArray: typing.List[str], int: int) -> typing.List[str]: ...
    @typing.overload
    @staticmethod
    def copyOf(doubleArray: typing.List[float], int: int) -> typing.List[float]: ...
    @typing.overload
    @staticmethod
    def copyOf(floatArray: typing.List[float], int: int) -> typing.List[float]: ...
    @typing.overload
    @staticmethod
    def copyOf(intArray: typing.List[int], int2: int) -> typing.List[int]: ...
    @typing.overload
    @staticmethod
    def copyOf(tArray: typing.List[_copyOf_6__T], int: int) -> typing.List[_copyOf_6__T]: ...
    @typing.overload
    @staticmethod
    def copyOf(uArray: typing.List[_copyOf_7__U], int: int, class_: typing.Type[typing.List[_copyOf_7__T]]) -> typing.List[_copyOf_7__T]: ...
    @typing.overload
    @staticmethod
    def copyOf(longArray: typing.List[int], int: int) -> typing.List[int]: ...
    @typing.overload
    @staticmethod
    def copyOf(shortArray: typing.List[int], int: int) -> typing.List[int]: ...
    _copyOfRange_6__T = typing.TypeVar('_copyOfRange_6__T')  # <T>
    _copyOfRange_7__T = typing.TypeVar('_copyOfRange_7__T')  # <T>
    _copyOfRange_7__U = typing.TypeVar('_copyOfRange_7__U')  # <U>
    @typing.overload
    @staticmethod
    def copyOfRange(booleanArray: typing.List[bool], int: int, int2: int) -> typing.List[bool]: ...
    @typing.overload
    @staticmethod
    def copyOfRange(byteArray: typing.List[int], int: int, int2: int) -> typing.List[int]: ...
    @typing.overload
    @staticmethod
    def copyOfRange(charArray: typing.List[str], int: int, int2: int) -> typing.List[str]: ...
    @typing.overload
    @staticmethod
    def copyOfRange(doubleArray: typing.List[float], int: int, int2: int) -> typing.List[float]: ...
    @typing.overload
    @staticmethod
    def copyOfRange(floatArray: typing.List[float], int: int, int2: int) -> typing.List[float]: ...
    @typing.overload
    @staticmethod
    def copyOfRange(intArray: typing.List[int], int2: int, int3: int) -> typing.List[int]: ...
    @typing.overload
    @staticmethod
    def copyOfRange(tArray: typing.List[_copyOfRange_6__T], int: int, int2: int) -> typing.List[_copyOfRange_6__T]: ...
    @typing.overload
    @staticmethod
    def copyOfRange(uArray: typing.List[_copyOfRange_7__U], int: int, int2: int, class_: typing.Type[typing.List[_copyOfRange_7__T]]) -> typing.List[_copyOfRange_7__T]: ...
    @typing.overload
    @staticmethod
    def copyOfRange(longArray: typing.List[int], int: int, int2: int) -> typing.List[int]: ...
    @typing.overload
    @staticmethod
    def copyOfRange(shortArray: typing.List[int], int: int, int2: int) -> typing.List[int]: ...
    @staticmethod
    def deepEquals(objectArray: typing.List[typing.Any], objectArray2: typing.List[typing.Any]) -> bool: ...
    @staticmethod
    def deepHashCode(objectArray: typing.List[typing.Any]) -> int: ...
    @staticmethod
    def deepToString(objectArray: typing.List[typing.Any]) -> str: ...
    @typing.overload
    def equals(self, object: typing.Any) -> bool: ...
    @typing.overload
    @staticmethod
    def equals(booleanArray: typing.List[bool], booleanArray2: typing.List[bool]) -> bool: ...
    @typing.overload
    @staticmethod
    def equals(byteArray: typing.List[int], byteArray2: typing.List[int]) -> bool: ...
    @typing.overload
    @staticmethod
    def equals(charArray: typing.List[str], charArray2: typing.List[str]) -> bool: ...
    @typing.overload
    @staticmethod
    def equals(doubleArray: typing.List[float], doubleArray2: typing.List[float]) -> bool: ...
    @typing.overload
    @staticmethod
    def equals(floatArray: typing.List[float], floatArray2: typing.List[float]) -> bool: ...
    @typing.overload
    @staticmethod
    def equals(intArray: typing.List[int], intArray2: typing.List[int]) -> bool: ...
    @typing.overload
    @staticmethod
    def equals(objectArray: typing.List[typing.Any], objectArray2: typing.List[typing.Any]) -> bool: ...
    @typing.overload
    @staticmethod
    def equals(longArray: typing.List[int], longArray2: typing.List[int]) -> bool: ...
    @typing.overload
    @staticmethod
    def equals(shortArray: typing.List[int], shortArray2: typing.List[int]) -> bool: ...
    @typing.overload
    @staticmethod
    def fill(booleanArray: typing.List[bool], boolean2: bool) -> None: ...
    @typing.overload
    @staticmethod
    def fill(booleanArray: typing.List[bool], int: int, int2: int, boolean2: bool) -> None: ...
    @typing.overload
    @staticmethod
    def fill(byteArray: typing.List[int], byte2: int) -> None: ...
    @typing.overload
    @staticmethod
    def fill(byteArray: typing.List[int], int: int, int2: int, byte2: int) -> None: ...
    @typing.overload
    @staticmethod
    def fill(charArray: typing.List[str], char2: str) -> None: ...
    @typing.overload
    @staticmethod
    def fill(charArray: typing.List[str], int: int, int2: int, char2: str) -> None: ...
    @typing.overload
    @staticmethod
    def fill(doubleArray: typing.List[float], double2: float) -> None: ...
    @typing.overload
    @staticmethod
    def fill(doubleArray: typing.List[float], int: int, int2: int, double2: float) -> None: ...
    @typing.overload
    @staticmethod
    def fill(floatArray: typing.List[float], float2: float) -> None: ...
    @typing.overload
    @staticmethod
    def fill(floatArray: typing.List[float], int: int, int2: int, float2: float) -> None: ...
    @typing.overload
    @staticmethod
    def fill(intArray: typing.List[int], int2: int) -> None: ...
    @typing.overload
    @staticmethod
    def fill(intArray: typing.List[int], int2: int, int3: int, int4: int) -> None: ...
    @typing.overload
    @staticmethod
    def fill(objectArray: typing.List[typing.Any], int: int, int2: int, object2: typing.Any) -> None: ...
    @typing.overload
    @staticmethod
    def fill(objectArray: typing.List[typing.Any], object2: typing.Any) -> None: ...
    @typing.overload
    @staticmethod
    def fill(longArray: typing.List[int], int: int, int2: int, long2: int) -> None: ...
    @typing.overload
    @staticmethod
    def fill(longArray: typing.List[int], long2: int) -> None: ...
    @typing.overload
    @staticmethod
    def fill(shortArray: typing.List[int], int: int, int2: int, short2: int) -> None: ...
    @typing.overload
    @staticmethod
    def fill(shortArray: typing.List[int], short2: int) -> None: ...
    @typing.overload
    def hashCode(self) -> int: ...
    @typing.overload
    @staticmethod
    def hashCode(booleanArray: typing.List[bool]) -> int: ...
    @typing.overload
    @staticmethod
    def hashCode(byteArray: typing.List[int]) -> int: ...
    @typing.overload
    @staticmethod
    def hashCode(charArray: typing.List[str]) -> int: ...
    @typing.overload
    @staticmethod
    def hashCode(doubleArray: typing.List[float]) -> int: ...
    @typing.overload
    @staticmethod
    def hashCode(floatArray: typing.List[float]) -> int: ...
    @typing.overload
    @staticmethod
    def hashCode(intArray: typing.List[int]) -> int: ...
    @typing.overload
    @staticmethod
    def hashCode(objectArray: typing.List[typing.Any]) -> int: ...
    @typing.overload
    @staticmethod
    def hashCode(longArray: typing.List[int]) -> int: ...
    @typing.overload
    @staticmethod
    def hashCode(shortArray: typing.List[int]) -> int: ...
    _parallelPrefix_4__T = typing.TypeVar('_parallelPrefix_4__T')  # <T>
    _parallelPrefix_5__T = typing.TypeVar('_parallelPrefix_5__T')  # <T>
    @typing.overload
    @staticmethod
    def parallelPrefix(doubleArray: typing.List[float], int: int, int2: int, doubleBinaryOperator: typing.Union[java.util.function.DoubleBinaryOperator, typing.Callable]) -> None: ...
    @typing.overload
    @staticmethod
    def parallelPrefix(doubleArray: typing.List[float], doubleBinaryOperator: typing.Union[java.util.function.DoubleBinaryOperator, typing.Callable]) -> None: ...
    @typing.overload
    @staticmethod
    def parallelPrefix(intArray: typing.List[int], int2: int, int3: int, intBinaryOperator: typing.Union[java.util.function.IntBinaryOperator, typing.Callable]) -> None: ...
    @typing.overload
    @staticmethod
    def parallelPrefix(intArray: typing.List[int], intBinaryOperator: typing.Union[java.util.function.IntBinaryOperator, typing.Callable]) -> None: ...
    @typing.overload
    @staticmethod
    def parallelPrefix(tArray: typing.List[_parallelPrefix_4__T], int: int, int2: int, binaryOperator: typing.Union[java.util.function.BinaryOperator[_parallelPrefix_4__T], typing.Callable]) -> None: ...
    @typing.overload
    @staticmethod
    def parallelPrefix(tArray: typing.List[_parallelPrefix_5__T], binaryOperator: typing.Union[java.util.function.BinaryOperator[_parallelPrefix_5__T], typing.Callable]) -> None: ...
    @typing.overload
    @staticmethod
    def parallelPrefix(longArray: typing.List[int], int: int, int2: int, longBinaryOperator: typing.Union[java.util.function.LongBinaryOperator, typing.Callable]) -> None: ...
    @typing.overload
    @staticmethod
    def parallelPrefix(longArray: typing.List[int], longBinaryOperator: typing.Union[java.util.function.LongBinaryOperator, typing.Callable]) -> None: ...
    _parallelSetAll_2__T = typing.TypeVar('_parallelSetAll_2__T')  # <T>
    @typing.overload
    @staticmethod
    def parallelSetAll(doubleArray: typing.List[float], intToDoubleFunction: typing.Union[java.util.function.IntToDoubleFunction, typing.Callable]) -> None: ...
    @typing.overload
    @staticmethod
    def parallelSetAll(intArray: typing.List[int], intUnaryOperator: typing.Union[java.util.function.IntUnaryOperator, typing.Callable]) -> None: ...
    @typing.overload
    @staticmethod
    def parallelSetAll(tArray: typing.List[_parallelSetAll_2__T], intFunction: typing.Union[java.util.function.IntFunction[_parallelSetAll_2__T], typing.Callable[[int], _parallelSetAll_2__T]]) -> None: ...
    @typing.overload
    @staticmethod
    def parallelSetAll(longArray: typing.List[int], intToLongFunction: typing.Union[java.util.function.IntToLongFunction, typing.Callable]) -> None: ...
    _parallelSort_10__T = typing.TypeVar('_parallelSort_10__T', bound=java.lang.Comparable)  # <T>
    _parallelSort_11__T = typing.TypeVar('_parallelSort_11__T', bound=java.lang.Comparable)  # <T>
    _parallelSort_12__T = typing.TypeVar('_parallelSort_12__T')  # <T>
    _parallelSort_13__T = typing.TypeVar('_parallelSort_13__T')  # <T>
    @typing.overload
    @staticmethod
    def parallelSort(byteArray: typing.List[int]) -> None: ...
    @typing.overload
    @staticmethod
    def parallelSort(byteArray: typing.List[int], int: int, int2: int) -> None: ...
    @typing.overload
    @staticmethod
    def parallelSort(charArray: typing.List[str]) -> None: ...
    @typing.overload
    @staticmethod
    def parallelSort(charArray: typing.List[str], int: int, int2: int) -> None: ...
    @typing.overload
    @staticmethod
    def parallelSort(doubleArray: typing.List[float]) -> None: ...
    @typing.overload
    @staticmethod
    def parallelSort(doubleArray: typing.List[float], int: int, int2: int) -> None: ...
    @typing.overload
    @staticmethod
    def parallelSort(floatArray: typing.List[float]) -> None: ...
    @typing.overload
    @staticmethod
    def parallelSort(floatArray: typing.List[float], int: int, int2: int) -> None: ...
    @typing.overload
    @staticmethod
    def parallelSort(intArray: typing.List[int]) -> None: ...
    @typing.overload
    @staticmethod
    def parallelSort(intArray: typing.List[int], int2: int, int3: int) -> None: ...
    @typing.overload
    @staticmethod
    def parallelSort(tArray: typing.List[_parallelSort_10__T]) -> None: ...
    @typing.overload
    @staticmethod
    def parallelSort(tArray: typing.List[_parallelSort_11__T], int: int, int2: int) -> None: ...
    @typing.overload
    @staticmethod
    def parallelSort(tArray: typing.List[_parallelSort_12__T], int: int, int2: int, comparator: typing.Union['Comparator'[_parallelSort_12__T], typing.Callable[[_parallelSort_12__T, _parallelSort_12__T], int]]) -> None: ...
    @typing.overload
    @staticmethod
    def parallelSort(tArray: typing.List[_parallelSort_13__T], comparator: typing.Union['Comparator'[_parallelSort_13__T], typing.Callable[[_parallelSort_13__T, _parallelSort_13__T], int]]) -> None: ...
    @typing.overload
    @staticmethod
    def parallelSort(longArray: typing.List[int]) -> None: ...
    @typing.overload
    @staticmethod
    def parallelSort(longArray: typing.List[int], int: int, int2: int) -> None: ...
    @typing.overload
    @staticmethod
    def parallelSort(shortArray: typing.List[int]) -> None: ...
    @typing.overload
    @staticmethod
    def parallelSort(shortArray: typing.List[int], int: int, int2: int) -> None: ...
    _setAll_2__T = typing.TypeVar('_setAll_2__T')  # <T>
    @typing.overload
    @staticmethod
    def setAll(doubleArray: typing.List[float], intToDoubleFunction: typing.Union[java.util.function.IntToDoubleFunction, typing.Callable]) -> None: ...
    @typing.overload
    @staticmethod
    def setAll(intArray: typing.List[int], intUnaryOperator: typing.Union[java.util.function.IntUnaryOperator, typing.Callable]) -> None: ...
    @typing.overload
    @staticmethod
    def setAll(tArray: typing.List[_setAll_2__T], intFunction: typing.Union[java.util.function.IntFunction[_setAll_2__T], typing.Callable[[int], _setAll_2__T]]) -> None: ...
    @typing.overload
    @staticmethod
    def setAll(longArray: typing.List[int], intToLongFunction: typing.Union[java.util.function.IntToLongFunction, typing.Callable]) -> None: ...
    _sort_12__T = typing.TypeVar('_sort_12__T')  # <T>
    _sort_13__T = typing.TypeVar('_sort_13__T')  # <T>
    @typing.overload
    @staticmethod
    def sort(byteArray: typing.List[int]) -> None: ...
    @typing.overload
    @staticmethod
    def sort(byteArray: typing.List[int], int: int, int2: int) -> None: ...
    @typing.overload
    @staticmethod
    def sort(charArray: typing.List[str]) -> None: ...
    @typing.overload
    @staticmethod
    def sort(charArray: typing.List[str], int: int, int2: int) -> None: ...
    @typing.overload
    @staticmethod
    def sort(doubleArray: typing.List[float]) -> None: ...
    @typing.overload
    @staticmethod
    def sort(doubleArray: typing.List[float], int: int, int2: int) -> None: ...
    @typing.overload
    @staticmethod
    def sort(floatArray: typing.List[float]) -> None: ...
    @typing.overload
    @staticmethod
    def sort(floatArray: typing.List[float], int: int, int2: int) -> None: ...
    @typing.overload
    @staticmethod
    def sort(intArray: typing.List[int]) -> None: ...
    @typing.overload
    @staticmethod
    def sort(intArray: typing.List[int], int2: int, int3: int) -> None: ...
    @typing.overload
    @staticmethod
    def sort(objectArray: typing.List[typing.Any]) -> None: ...
    @typing.overload
    @staticmethod
    def sort(objectArray: typing.List[typing.Any], int: int, int2: int) -> None: ...
    @typing.overload
    @staticmethod
    def sort(tArray: typing.List[_sort_12__T], int: int, int2: int, comparator: typing.Union['Comparator'[_sort_12__T], typing.Callable[[_sort_12__T, _sort_12__T], int]]) -> None: ...
    @typing.overload
    @staticmethod
    def sort(tArray: typing.List[_sort_13__T], comparator: typing.Union['Comparator'[_sort_13__T], typing.Callable[[_sort_13__T, _sort_13__T], int]]) -> None: ...
    @typing.overload
    @staticmethod
    def sort(longArray: typing.List[int]) -> None: ...
    @typing.overload
    @staticmethod
    def sort(longArray: typing.List[int], int: int, int2: int) -> None: ...
    @typing.overload
    @staticmethod
    def sort(shortArray: typing.List[int]) -> None: ...
    @typing.overload
    @staticmethod
    def sort(shortArray: typing.List[int], int: int, int2: int) -> None: ...
    _spliterator_0__T = typing.TypeVar('_spliterator_0__T')  # <T>
    _spliterator_1__T = typing.TypeVar('_spliterator_1__T')  # <T>
    @typing.overload
    @staticmethod
    def spliterator(tArray: typing.List[_spliterator_0__T]) -> 'Spliterator'[_spliterator_0__T]: ...
    @typing.overload
    @staticmethod
    def spliterator(tArray: typing.List[_spliterator_1__T], int: int, int2: int) -> 'Spliterator'[_spliterator_1__T]: ...
    @typing.overload
    @staticmethod
    def spliterator(doubleArray: typing.List[float]) -> 'Spliterator.OfDouble': ...
    @typing.overload
    @staticmethod
    def spliterator(doubleArray: typing.List[float], int: int, int2: int) -> 'Spliterator.OfDouble': ...
    @typing.overload
    @staticmethod
    def spliterator(intArray: typing.List[int]) -> 'Spliterator.OfInt': ...
    @typing.overload
    @staticmethod
    def spliterator(intArray: typing.List[int], int2: int, int3: int) -> 'Spliterator.OfInt': ...
    @typing.overload
    @staticmethod
    def spliterator(longArray: typing.List[int]) -> 'Spliterator.OfLong': ...
    @typing.overload
    @staticmethod
    def spliterator(longArray: typing.List[int], int: int, int2: int) -> 'Spliterator.OfLong': ...
    _stream_6__T = typing.TypeVar('_stream_6__T')  # <T>
    _stream_7__T = typing.TypeVar('_stream_7__T')  # <T>
    @typing.overload
    @staticmethod
    def stream(doubleArray: typing.List[float]) -> java.util.stream.DoubleStream: ...
    @typing.overload
    @staticmethod
    def stream(doubleArray: typing.List[float], int: int, int2: int) -> java.util.stream.DoubleStream: ...
    @typing.overload
    @staticmethod
    def stream(intArray: typing.List[int]) -> java.util.stream.IntStream: ...
    @typing.overload
    @staticmethod
    def stream(intArray: typing.List[int], int2: int, int3: int) -> java.util.stream.IntStream: ...
    @typing.overload
    @staticmethod
    def stream(longArray: typing.List[int]) -> java.util.stream.LongStream: ...
    @typing.overload
    @staticmethod
    def stream(longArray: typing.List[int], int: int, int2: int) -> java.util.stream.LongStream: ...
    @typing.overload
    @staticmethod
    def stream(tArray: typing.List[_stream_6__T]) -> java.util.stream.Stream[_stream_6__T]: ...
    @typing.overload
    @staticmethod
    def stream(tArray: typing.List[_stream_7__T], int: int, int2: int) -> java.util.stream.Stream[_stream_7__T]: ...
    @typing.overload
    def toString(self) -> str: ...
    @typing.overload
    @staticmethod
    def toString(booleanArray: typing.List[bool]) -> str: ...
    @typing.overload
    @staticmethod
    def toString(byteArray: typing.List[int]) -> str: ...
    @typing.overload
    @staticmethod
    def toString(charArray: typing.List[str]) -> str: ...
    @typing.overload
    @staticmethod
    def toString(doubleArray: typing.List[float]) -> str: ...
    @typing.overload
    @staticmethod
    def toString(floatArray: typing.List[float]) -> str: ...
    @typing.overload
    @staticmethod
    def toString(intArray: typing.List[int]) -> str: ...
    @typing.overload
    @staticmethod
    def toString(objectArray: typing.List[typing.Any]) -> str: ...
    @typing.overload
    @staticmethod
    def toString(longArray: typing.List[int]) -> str: ...
    @typing.overload
    @staticmethod
    def toString(shortArray: typing.List[int]) -> str: ...

class Base64:
    @staticmethod
    def getDecoder() -> 'Base64.Decoder': ...
    @staticmethod
    def getEncoder() -> 'Base64.Encoder': ...
    @staticmethod
    def getMimeDecoder() -> 'Base64.Decoder': ...
    @typing.overload
    @staticmethod
    def getMimeEncoder() -> 'Base64.Encoder': ...
    @typing.overload
    @staticmethod
    def getMimeEncoder(int: int, byteArray: typing.List[int]) -> 'Base64.Encoder': ...
    @staticmethod
    def getUrlDecoder() -> 'Base64.Decoder': ...
    @staticmethod
    def getUrlEncoder() -> 'Base64.Encoder': ...
    class Decoder:
        @typing.overload
        def decode(self, byteArray: typing.List[int]) -> typing.List[int]: ...
        @typing.overload
        def decode(self, string: str) -> typing.List[int]: ...
        @typing.overload
        def decode(self, byteArray: typing.List[int], byteArray2: typing.List[int]) -> int: ...
        @typing.overload
        def decode(self, byteBuffer: java.nio.ByteBuffer) -> java.nio.ByteBuffer: ...
        def wrap(self, inputStream: java.io.InputStream) -> java.io.InputStream: ...
    class Encoder:
        @typing.overload
        def encode(self, byteArray: typing.List[int]) -> typing.List[int]: ...
        @typing.overload
        def encode(self, byteArray: typing.List[int], byteArray2: typing.List[int]) -> int: ...
        @typing.overload
        def encode(self, byteBuffer: java.nio.ByteBuffer) -> java.nio.ByteBuffer: ...
        def encodeToString(self, byteArray: typing.List[int]) -> str: ...
        def withoutPadding(self) -> 'Base64.Encoder': ...
        def wrap(self, outputStream: java.io.OutputStream) -> java.io.OutputStream: ...

class BitSet(java.lang.Cloneable, java.io.Serializable):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    def andNot(self, bitSet: 'BitSet') -> None: ...
    def cardinality(self) -> int: ...
    @typing.overload
    def clear(self) -> None: ...
    @typing.overload
    def clear(self, int: int) -> None: ...
    @typing.overload
    def clear(self, int: int, int2: int) -> None: ...
    def clone(self) -> typing.Any: ...
    def equals(self, object: typing.Any) -> bool: ...
    @typing.overload
    def flip(self, int: int) -> None: ...
    @typing.overload
    def flip(self, int: int, int2: int) -> None: ...
    @typing.overload
    def get(self, int: int) -> bool: ...
    @typing.overload
    def get(self, int: int, int2: int) -> 'BitSet': ...
    def hashCode(self) -> int: ...
    def intersects(self, bitSet: 'BitSet') -> bool: ...
    def isEmpty(self) -> bool: ...
    def length(self) -> int: ...
    def nextClearBit(self, int: int) -> int: ...
    def nextSetBit(self, int: int) -> int: ...
    def previousClearBit(self, int: int) -> int: ...
    def previousSetBit(self, int: int) -> int: ...
    @typing.overload
    def set(self, int: int) -> None: ...
    @typing.overload
    def set(self, int: int, boolean: bool) -> None: ...
    @typing.overload
    def set(self, int: int, int2: int) -> None: ...
    @typing.overload
    def set(self, int: int, int2: int, boolean: bool) -> None: ...
    def size(self) -> int: ...
    def stream(self) -> java.util.stream.IntStream: ...
    def toByteArray(self) -> typing.List[int]: ...
    def toLongArray(self) -> typing.List[int]: ...
    def toString(self) -> str: ...
    @typing.overload
    @staticmethod
    def valueOf(byteArray: typing.List[int]) -> 'BitSet': ...
    @typing.overload
    @staticmethod
    def valueOf(byteBuffer: java.nio.ByteBuffer) -> 'BitSet': ...
    @typing.overload
    @staticmethod
    def valueOf(longBuffer: java.nio.LongBuffer) -> 'BitSet': ...
    @typing.overload
    @staticmethod
    def valueOf(longArray: typing.List[int]) -> 'BitSet': ...
    def xor(self, bitSet: 'BitSet') -> None: ...

class Calendar(java.io.Serializable, java.lang.Cloneable, java.lang.Comparable['Calendar']):
    ERA: typing.ClassVar[int] = ...
    YEAR: typing.ClassVar[int] = ...
    MONTH: typing.ClassVar[int] = ...
    WEEK_OF_YEAR: typing.ClassVar[int] = ...
    WEEK_OF_MONTH: typing.ClassVar[int] = ...
    DATE: typing.ClassVar[int] = ...
    DAY_OF_MONTH: typing.ClassVar[int] = ...
    DAY_OF_YEAR: typing.ClassVar[int] = ...
    DAY_OF_WEEK: typing.ClassVar[int] = ...
    DAY_OF_WEEK_IN_MONTH: typing.ClassVar[int] = ...
    AM_PM: typing.ClassVar[int] = ...
    HOUR: typing.ClassVar[int] = ...
    HOUR_OF_DAY: typing.ClassVar[int] = ...
    MINUTE: typing.ClassVar[int] = ...
    SECOND: typing.ClassVar[int] = ...
    MILLISECOND: typing.ClassVar[int] = ...
    ZONE_OFFSET: typing.ClassVar[int] = ...
    DST_OFFSET: typing.ClassVar[int] = ...
    FIELD_COUNT: typing.ClassVar[int] = ...
    SUNDAY: typing.ClassVar[int] = ...
    MONDAY: typing.ClassVar[int] = ...
    TUESDAY: typing.ClassVar[int] = ...
    WEDNESDAY: typing.ClassVar[int] = ...
    THURSDAY: typing.ClassVar[int] = ...
    FRIDAY: typing.ClassVar[int] = ...
    SATURDAY: typing.ClassVar[int] = ...
    JANUARY: typing.ClassVar[int] = ...
    FEBRUARY: typing.ClassVar[int] = ...
    MARCH: typing.ClassVar[int] = ...
    APRIL: typing.ClassVar[int] = ...
    MAY: typing.ClassVar[int] = ...
    JUNE: typing.ClassVar[int] = ...
    JULY: typing.ClassVar[int] = ...
    AUGUST: typing.ClassVar[int] = ...
    SEPTEMBER: typing.ClassVar[int] = ...
    OCTOBER: typing.ClassVar[int] = ...
    NOVEMBER: typing.ClassVar[int] = ...
    DECEMBER: typing.ClassVar[int] = ...
    UNDECIMBER: typing.ClassVar[int] = ...
    AM: typing.ClassVar[int] = ...
    PM: typing.ClassVar[int] = ...
    ALL_STYLES: typing.ClassVar[int] = ...
    SHORT: typing.ClassVar[int] = ...
    LONG: typing.ClassVar[int] = ...
    NARROW_FORMAT: typing.ClassVar[int] = ...
    NARROW_STANDALONE: typing.ClassVar[int] = ...
    SHORT_FORMAT: typing.ClassVar[int] = ...
    LONG_FORMAT: typing.ClassVar[int] = ...
    SHORT_STANDALONE: typing.ClassVar[int] = ...
    LONG_STANDALONE: typing.ClassVar[int] = ...
    def add(self, int: int, int2: int) -> None: ...
    def after(self, object: typing.Any) -> bool: ...
    def before(self, object: typing.Any) -> bool: ...
    @typing.overload
    def clear(self) -> None: ...
    @typing.overload
    def clear(self, int: int) -> None: ...
    def clone(self) -> typing.Any: ...
    def compareTo(self, calendar: 'Calendar') -> int: ...
    def equals(self, object: typing.Any) -> bool: ...
    def get(self, int: int) -> int: ...
    def getActualMaximum(self, int: int) -> int: ...
    def getActualMinimum(self, int: int) -> int: ...
    @staticmethod
    def getAvailableCalendarTypes() -> 'Set'[str]: ...
    @staticmethod
    def getAvailableLocales() -> typing.List['Locale']: ...
    def getCalendarType(self) -> str: ...
    def getDisplayName(self, int: int, int2: int, locale: 'Locale') -> str: ...
    def getDisplayNames(self, int: int, int2: int, locale: 'Locale') -> 'Map'[str, int]: ...
    def getFirstDayOfWeek(self) -> int: ...
    def getGreatestMinimum(self, int: int) -> int: ...
    @typing.overload
    @staticmethod
    def getInstance() -> 'Calendar': ...
    @typing.overload
    @staticmethod
    def getInstance(locale: 'Locale') -> 'Calendar': ...
    @typing.overload
    @staticmethod
    def getInstance(timeZone: 'TimeZone') -> 'Calendar': ...
    @typing.overload
    @staticmethod
    def getInstance(timeZone: 'TimeZone', locale: 'Locale') -> 'Calendar': ...
    def getLeastMaximum(self, int: int) -> int: ...
    def getMaximum(self, int: int) -> int: ...
    def getMinimalDaysInFirstWeek(self) -> int: ...
    def getMinimum(self, int: int) -> int: ...
    def getTime(self) -> 'Date': ...
    def getTimeInMillis(self) -> int: ...
    def getTimeZone(self) -> 'TimeZone': ...
    def getWeekYear(self) -> int: ...
    def getWeeksInWeekYear(self) -> int: ...
    def hashCode(self) -> int: ...
    def isLenient(self) -> bool: ...
    def isSet(self, int: int) -> bool: ...
    def isWeekDateSupported(self) -> bool: ...
    @typing.overload
    def roll(self, int: int, boolean: bool) -> None: ...
    @typing.overload
    def roll(self, int: int, int2: int) -> None: ...
    @typing.overload
    def set(self, int: int, int2: int, int3: int) -> None: ...
    @typing.overload
    def set(self, int: int, int2: int, int3: int, int4: int, int5: int) -> None: ...
    @typing.overload
    def set(self, int: int, int2: int, int3: int, int4: int, int5: int, int6: int) -> None: ...
    @typing.overload
    def set(self, int: int, int2: int) -> None: ...
    def setFirstDayOfWeek(self, int: int) -> None: ...
    def setLenient(self, boolean: bool) -> None: ...
    def setMinimalDaysInFirstWeek(self, int: int) -> None: ...
    def setTime(self, date: 'Date') -> None: ...
    def setTimeInMillis(self, long: int) -> None: ...
    def setTimeZone(self, timeZone: 'TimeZone') -> None: ...
    def setWeekDate(self, int: int, int2: int, int3: int) -> None: ...
    def toInstant(self) -> java.time.Instant: ...
    def toString(self) -> str: ...
    class Builder:
        def __init__(self): ...
        def build(self) -> 'Calendar': ...
        def set(self, int: int, int2: int) -> 'Calendar.Builder': ...
        def setCalendarType(self, string: str) -> 'Calendar.Builder': ...
        def setDate(self, int: int, int2: int, int3: int) -> 'Calendar.Builder': ...
        def setFields(self, intArray: typing.List[int]) -> 'Calendar.Builder': ...
        @typing.overload
        def setInstant(self, date: 'Date') -> 'Calendar.Builder': ...
        @typing.overload
        def setInstant(self, long: int) -> 'Calendar.Builder': ...
        def setLenient(self, boolean: bool) -> 'Calendar.Builder': ...
        def setLocale(self, locale: 'Locale') -> 'Calendar.Builder': ...
        @typing.overload
        def setTimeOfDay(self, int: int, int2: int, int3: int) -> 'Calendar.Builder': ...
        @typing.overload
        def setTimeOfDay(self, int: int, int2: int, int3: int, int4: int) -> 'Calendar.Builder': ...
        def setTimeZone(self, timeZone: 'TimeZone') -> 'Calendar.Builder': ...
        def setWeekDate(self, int: int, int2: int, int3: int) -> 'Calendar.Builder': ...
        def setWeekDefinition(self, int: int, int2: int) -> 'Calendar.Builder': ...

_Collection__E = typing.TypeVar('_Collection__E')  # <E>
class Collection(java.lang.Iterable[_Collection__E], typing.Generic[_Collection__E], _JCollection[_Collection__E]):
    def add(self, e: _Collection__E) -> bool: ...
    def addAll(self, collection: typing.Union['Collection'[_Collection__E], typing.Sequence[_Collection__E], typing.Set[_Collection__E]]) -> bool: ...
    def clear(self) -> None: ...
    def contains(self, object: typing.Any) -> bool: ...
    def containsAll(self, collection: typing.Union['Collection'[typing.Any], typing.Sequence[typing.Any], typing.Set[typing.Any]]) -> bool: ...
    def equals(self, object: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> 'Iterator'[_Collection__E]: ...
    def parallelStream(self) -> java.util.stream.Stream[_Collection__E]: ...
    def remove(self, object: typing.Any) -> bool: ...
    def removeAll(self, collection: typing.Union['Collection'[typing.Any], typing.Sequence[typing.Any], typing.Set[typing.Any]]) -> bool: ...
    def removeIf(self, predicate: typing.Union[java.util.function.Predicate[_Collection__E], typing.Callable[[_Collection__E], bool]]) -> bool: ...
    def retainAll(self, collection: typing.Union['Collection'[typing.Any], typing.Sequence[typing.Any], typing.Set[typing.Any]]) -> bool: ...
    def size(self) -> int: ...
    def spliterator(self) -> 'Spliterator'[_Collection__E]: ...
    def stream(self) -> java.util.stream.Stream[_Collection__E]: ...
    _toArray_1__T = typing.TypeVar('_toArray_1__T')  # <T>
    @typing.overload
    def toArray(self) -> typing.List[typing.Any]: ...
    @typing.overload
    def toArray(self, tArray: typing.List[_toArray_1__T]) -> typing.List[_toArray_1__T]: ...

class Collections:
    EMPTY_SET: typing.ClassVar['Set'] = ...
    EMPTY_LIST: typing.ClassVar['List'] = ...
    EMPTY_MAP: typing.ClassVar['Map'] = ...
    _addAll__T = typing.TypeVar('_addAll__T')  # <T>
    @staticmethod
    def addAll(collection: typing.Union[Collection[_addAll__T], typing.Sequence[_addAll__T], typing.Set[_addAll__T]], tArray: typing.List[_addAll__T]) -> bool: ...
    _asLifoQueue__T = typing.TypeVar('_asLifoQueue__T')  # <T>
    @staticmethod
    def asLifoQueue(deque: 'Deque'[_asLifoQueue__T]) -> 'Queue'[_asLifoQueue__T]: ...
    _binarySearch_0__T = typing.TypeVar('_binarySearch_0__T')  # <T>
    _binarySearch_1__T = typing.TypeVar('_binarySearch_1__T')  # <T>
    @typing.overload
    @staticmethod
    def binarySearch(list: 'List'[java.lang.Comparable[_binarySearch_0__T]], t: _binarySearch_0__T) -> int: ...
    @typing.overload
    @staticmethod
    def binarySearch(list: 'List'[_binarySearch_1__T], t: _binarySearch_1__T, comparator: typing.Union['Comparator'[_binarySearch_1__T], typing.Callable[[_binarySearch_1__T, _binarySearch_1__T], int]]) -> int: ...
    _checkedCollection__E = typing.TypeVar('_checkedCollection__E')  # <E>
    @staticmethod
    def checkedCollection(collection: typing.Union[Collection[_checkedCollection__E], typing.Sequence[_checkedCollection__E], typing.Set[_checkedCollection__E]], class_: typing.Type[_checkedCollection__E]) -> Collection[_checkedCollection__E]: ...
    _checkedList__E = typing.TypeVar('_checkedList__E')  # <E>
    @staticmethod
    def checkedList(list: 'List'[_checkedList__E], class_: typing.Type[_checkedList__E]) -> 'List'[_checkedList__E]: ...
    _checkedMap__K = typing.TypeVar('_checkedMap__K')  # <K>
    _checkedMap__V = typing.TypeVar('_checkedMap__V')  # <V>
    @staticmethod
    def checkedMap(map: typing.Union['Map'[_checkedMap__K, _checkedMap__V], typing.Mapping[_checkedMap__K, _checkedMap__V]], class_: typing.Type[_checkedMap__K], class2: typing.Type[_checkedMap__V]) -> 'Map'[_checkedMap__K, _checkedMap__V]: ...
    _checkedNavigableMap__K = typing.TypeVar('_checkedNavigableMap__K')  # <K>
    _checkedNavigableMap__V = typing.TypeVar('_checkedNavigableMap__V')  # <V>
    @staticmethod
    def checkedNavigableMap(navigableMap: 'NavigableMap'[_checkedNavigableMap__K, _checkedNavigableMap__V], class_: typing.Type[_checkedNavigableMap__K], class2: typing.Type[_checkedNavigableMap__V]) -> 'NavigableMap'[_checkedNavigableMap__K, _checkedNavigableMap__V]: ...
    _checkedNavigableSet__E = typing.TypeVar('_checkedNavigableSet__E')  # <E>
    @staticmethod
    def checkedNavigableSet(navigableSet: 'NavigableSet'[_checkedNavigableSet__E], class_: typing.Type[_checkedNavigableSet__E]) -> 'NavigableSet'[_checkedNavigableSet__E]: ...
    _checkedQueue__E = typing.TypeVar('_checkedQueue__E')  # <E>
    @staticmethod
    def checkedQueue(queue: 'Queue'[_checkedQueue__E], class_: typing.Type[_checkedQueue__E]) -> 'Queue'[_checkedQueue__E]: ...
    _checkedSet__E = typing.TypeVar('_checkedSet__E')  # <E>
    @staticmethod
    def checkedSet(set: 'Set'[_checkedSet__E], class_: typing.Type[_checkedSet__E]) -> 'Set'[_checkedSet__E]: ...
    _checkedSortedMap__K = typing.TypeVar('_checkedSortedMap__K')  # <K>
    _checkedSortedMap__V = typing.TypeVar('_checkedSortedMap__V')  # <V>
    @staticmethod
    def checkedSortedMap(sortedMap: 'SortedMap'[_checkedSortedMap__K, _checkedSortedMap__V], class_: typing.Type[_checkedSortedMap__K], class2: typing.Type[_checkedSortedMap__V]) -> 'SortedMap'[_checkedSortedMap__K, _checkedSortedMap__V]: ...
    _checkedSortedSet__E = typing.TypeVar('_checkedSortedSet__E')  # <E>
    @staticmethod
    def checkedSortedSet(sortedSet: 'SortedSet'[_checkedSortedSet__E], class_: typing.Type[_checkedSortedSet__E]) -> 'SortedSet'[_checkedSortedSet__E]: ...
    _copy__T = typing.TypeVar('_copy__T')  # <T>
    @staticmethod
    def copy(list: 'List'[_copy__T], list2: 'List'[_copy__T]) -> None: ...
    @staticmethod
    def disjoint(collection: typing.Union[Collection[typing.Any], typing.Sequence[typing.Any], typing.Set[typing.Any]], collection2: typing.Union[Collection[typing.Any], typing.Sequence[typing.Any], typing.Set[typing.Any]]) -> bool: ...
    _emptyEnumeration__T = typing.TypeVar('_emptyEnumeration__T')  # <T>
    @staticmethod
    def emptyEnumeration() -> 'Enumeration'[_emptyEnumeration__T]: ...
    _emptyIterator__T = typing.TypeVar('_emptyIterator__T')  # <T>
    @staticmethod
    def emptyIterator() -> 'Iterator'[_emptyIterator__T]: ...
    _emptyList__T = typing.TypeVar('_emptyList__T')  # <T>
    @staticmethod
    def emptyList() -> 'List'[_emptyList__T]: ...
    _emptyListIterator__T = typing.TypeVar('_emptyListIterator__T')  # <T>
    @staticmethod
    def emptyListIterator() -> 'ListIterator'[_emptyListIterator__T]: ...
    _emptyMap__K = typing.TypeVar('_emptyMap__K')  # <K>
    _emptyMap__V = typing.TypeVar('_emptyMap__V')  # <V>
    @staticmethod
    def emptyMap() -> 'Map'[_emptyMap__K, _emptyMap__V]: ...
    _emptyNavigableMap__K = typing.TypeVar('_emptyNavigableMap__K')  # <K>
    _emptyNavigableMap__V = typing.TypeVar('_emptyNavigableMap__V')  # <V>
    @staticmethod
    def emptyNavigableMap() -> 'NavigableMap'[_emptyNavigableMap__K, _emptyNavigableMap__V]: ...
    _emptyNavigableSet__E = typing.TypeVar('_emptyNavigableSet__E')  # <E>
    @staticmethod
    def emptyNavigableSet() -> 'NavigableSet'[_emptyNavigableSet__E]: ...
    _emptySet__T = typing.TypeVar('_emptySet__T')  # <T>
    @staticmethod
    def emptySet() -> 'Set'[_emptySet__T]: ...
    _emptySortedMap__K = typing.TypeVar('_emptySortedMap__K')  # <K>
    _emptySortedMap__V = typing.TypeVar('_emptySortedMap__V')  # <V>
    @staticmethod
    def emptySortedMap() -> 'SortedMap'[_emptySortedMap__K, _emptySortedMap__V]: ...
    _emptySortedSet__E = typing.TypeVar('_emptySortedSet__E')  # <E>
    @staticmethod
    def emptySortedSet() -> 'SortedSet'[_emptySortedSet__E]: ...
    _enumeration__T = typing.TypeVar('_enumeration__T')  # <T>
    @staticmethod
    def enumeration(collection: typing.Union[Collection[_enumeration__T], typing.Sequence[_enumeration__T], typing.Set[_enumeration__T]]) -> 'Enumeration'[_enumeration__T]: ...
    _fill__T = typing.TypeVar('_fill__T')  # <T>
    @staticmethod
    def fill(list: 'List'[_fill__T], t: _fill__T) -> None: ...
    @staticmethod
    def frequency(collection: typing.Union[Collection[typing.Any], typing.Sequence[typing.Any], typing.Set[typing.Any]], object: typing.Any) -> int: ...
    @staticmethod
    def indexOfSubList(list: 'List'[typing.Any], list2: 'List'[typing.Any]) -> int: ...
    @staticmethod
    def lastIndexOfSubList(list: 'List'[typing.Any], list2: 'List'[typing.Any]) -> int: ...
    _list__T = typing.TypeVar('_list__T')  # <T>
    @staticmethod
    def list(enumeration: 'Enumeration'[_list__T]) -> 'ArrayList'[_list__T]: ...
    _max_0__T = typing.TypeVar('_max_0__T')  # <T>
    _max_1__T = typing.TypeVar('_max_1__T')  # <T>
    @typing.overload
    @staticmethod
    def max(collection: typing.Union[Collection[_max_0__T], typing.Sequence[_max_0__T], typing.Set[_max_0__T]]) -> _max_0__T: ...
    @typing.overload
    @staticmethod
    def max(collection: typing.Union[Collection[_max_1__T], typing.Sequence[_max_1__T], typing.Set[_max_1__T]], comparator: typing.Union['Comparator'[_max_1__T], typing.Callable[[_max_1__T, _max_1__T], int]]) -> _max_1__T: ...
    _min_0__T = typing.TypeVar('_min_0__T')  # <T>
    _min_1__T = typing.TypeVar('_min_1__T')  # <T>
    @typing.overload
    @staticmethod
    def min(collection: typing.Union[Collection[_min_0__T], typing.Sequence[_min_0__T], typing.Set[_min_0__T]]) -> _min_0__T: ...
    @typing.overload
    @staticmethod
    def min(collection: typing.Union[Collection[_min_1__T], typing.Sequence[_min_1__T], typing.Set[_min_1__T]], comparator: typing.Union['Comparator'[_min_1__T], typing.Callable[[_min_1__T, _min_1__T], int]]) -> _min_1__T: ...
    _nCopies__T = typing.TypeVar('_nCopies__T')  # <T>
    @staticmethod
    def nCopies(int: int, t: _nCopies__T) -> 'List'[_nCopies__T]: ...
    _newSetFromMap__E = typing.TypeVar('_newSetFromMap__E')  # <E>
    @staticmethod
    def newSetFromMap(map: typing.Union['Map'[_newSetFromMap__E, bool], typing.Mapping[_newSetFromMap__E, bool]]) -> 'Set'[_newSetFromMap__E]: ...
    _replaceAll__T = typing.TypeVar('_replaceAll__T')  # <T>
    @staticmethod
    def replaceAll(list: 'List'[_replaceAll__T], t: _replaceAll__T, t2: _replaceAll__T) -> bool: ...
    @staticmethod
    def reverse(list: 'List'[typing.Any]) -> None: ...
    _reverseOrder_0__T = typing.TypeVar('_reverseOrder_0__T')  # <T>
    _reverseOrder_1__T = typing.TypeVar('_reverseOrder_1__T')  # <T>
    @typing.overload
    @staticmethod
    def reverseOrder() -> 'Comparator'[_reverseOrder_0__T]: ...
    @typing.overload
    @staticmethod
    def reverseOrder(comparator: typing.Union['Comparator'[_reverseOrder_1__T], typing.Callable[[_reverseOrder_1__T, _reverseOrder_1__T], int]]) -> 'Comparator'[_reverseOrder_1__T]: ...
    @staticmethod
    def rotate(list: 'List'[typing.Any], int: int) -> None: ...
    @typing.overload
    @staticmethod
    def shuffle(list: 'List'[typing.Any]) -> None: ...
    @typing.overload
    @staticmethod
    def shuffle(list: 'List'[typing.Any], random: 'Random') -> None: ...
    _singleton__T = typing.TypeVar('_singleton__T')  # <T>
    @staticmethod
    def singleton(t: _singleton__T) -> 'Set'[_singleton__T]: ...
    _singletonList__T = typing.TypeVar('_singletonList__T')  # <T>
    @staticmethod
    def singletonList(t: _singletonList__T) -> 'List'[_singletonList__T]: ...
    _singletonMap__K = typing.TypeVar('_singletonMap__K')  # <K>
    _singletonMap__V = typing.TypeVar('_singletonMap__V')  # <V>
    @staticmethod
    def singletonMap(k: _singletonMap__K, v: _singletonMap__V) -> 'Map'[_singletonMap__K, _singletonMap__V]: ...
    _sort_0__T = typing.TypeVar('_sort_0__T', bound=java.lang.Comparable)  # <T>
    _sort_1__T = typing.TypeVar('_sort_1__T')  # <T>
    @typing.overload
    @staticmethod
    def sort(list: 'List'[_sort_0__T]) -> None: ...
    @typing.overload
    @staticmethod
    def sort(list: 'List'[_sort_1__T], comparator: typing.Union['Comparator'[_sort_1__T], typing.Callable[[_sort_1__T, _sort_1__T], int]]) -> None: ...
    @staticmethod
    def swap(list: 'List'[typing.Any], int: int, int2: int) -> None: ...
    _synchronizedCollection__T = typing.TypeVar('_synchronizedCollection__T')  # <T>
    @staticmethod
    def synchronizedCollection(collection: typing.Union[Collection[_synchronizedCollection__T], typing.Sequence[_synchronizedCollection__T], typing.Set[_synchronizedCollection__T]]) -> Collection[_synchronizedCollection__T]: ...
    _synchronizedList__T = typing.TypeVar('_synchronizedList__T')  # <T>
    @staticmethod
    def synchronizedList(list: 'List'[_synchronizedList__T]) -> 'List'[_synchronizedList__T]: ...
    _synchronizedMap__K = typing.TypeVar('_synchronizedMap__K')  # <K>
    _synchronizedMap__V = typing.TypeVar('_synchronizedMap__V')  # <V>
    @staticmethod
    def synchronizedMap(map: typing.Union['Map'[_synchronizedMap__K, _synchronizedMap__V], typing.Mapping[_synchronizedMap__K, _synchronizedMap__V]]) -> 'Map'[_synchronizedMap__K, _synchronizedMap__V]: ...
    _synchronizedNavigableMap__K = typing.TypeVar('_synchronizedNavigableMap__K')  # <K>
    _synchronizedNavigableMap__V = typing.TypeVar('_synchronizedNavigableMap__V')  # <V>
    @staticmethod
    def synchronizedNavigableMap(navigableMap: 'NavigableMap'[_synchronizedNavigableMap__K, _synchronizedNavigableMap__V]) -> 'NavigableMap'[_synchronizedNavigableMap__K, _synchronizedNavigableMap__V]: ...
    _synchronizedNavigableSet__T = typing.TypeVar('_synchronizedNavigableSet__T')  # <T>
    @staticmethod
    def synchronizedNavigableSet(navigableSet: 'NavigableSet'[_synchronizedNavigableSet__T]) -> 'NavigableSet'[_synchronizedNavigableSet__T]: ...
    _synchronizedSet__T = typing.TypeVar('_synchronizedSet__T')  # <T>
    @staticmethod
    def synchronizedSet(set: 'Set'[_synchronizedSet__T]) -> 'Set'[_synchronizedSet__T]: ...
    _synchronizedSortedMap__K = typing.TypeVar('_synchronizedSortedMap__K')  # <K>
    _synchronizedSortedMap__V = typing.TypeVar('_synchronizedSortedMap__V')  # <V>
    @staticmethod
    def synchronizedSortedMap(sortedMap: 'SortedMap'[_synchronizedSortedMap__K, _synchronizedSortedMap__V]) -> 'SortedMap'[_synchronizedSortedMap__K, _synchronizedSortedMap__V]: ...
    _synchronizedSortedSet__T = typing.TypeVar('_synchronizedSortedSet__T')  # <T>
    @staticmethod
    def synchronizedSortedSet(sortedSet: 'SortedSet'[_synchronizedSortedSet__T]) -> 'SortedSet'[_synchronizedSortedSet__T]: ...
    _unmodifiableCollection__T = typing.TypeVar('_unmodifiableCollection__T')  # <T>
    @staticmethod
    def unmodifiableCollection(collection: typing.Union[Collection[_unmodifiableCollection__T], typing.Sequence[_unmodifiableCollection__T], typing.Set[_unmodifiableCollection__T]]) -> Collection[_unmodifiableCollection__T]: ...
    _unmodifiableList__T = typing.TypeVar('_unmodifiableList__T')  # <T>
    @staticmethod
    def unmodifiableList(list: 'List'[_unmodifiableList__T]) -> 'List'[_unmodifiableList__T]: ...
    _unmodifiableMap__K = typing.TypeVar('_unmodifiableMap__K')  # <K>
    _unmodifiableMap__V = typing.TypeVar('_unmodifiableMap__V')  # <V>
    @staticmethod
    def unmodifiableMap(map: typing.Union['Map'[_unmodifiableMap__K, _unmodifiableMap__V], typing.Mapping[_unmodifiableMap__K, _unmodifiableMap__V]]) -> 'Map'[_unmodifiableMap__K, _unmodifiableMap__V]: ...
    _unmodifiableNavigableMap__K = typing.TypeVar('_unmodifiableNavigableMap__K')  # <K>
    _unmodifiableNavigableMap__V = typing.TypeVar('_unmodifiableNavigableMap__V')  # <V>
    @staticmethod
    def unmodifiableNavigableMap(navigableMap: 'NavigableMap'[_unmodifiableNavigableMap__K, _unmodifiableNavigableMap__V]) -> 'NavigableMap'[_unmodifiableNavigableMap__K, _unmodifiableNavigableMap__V]: ...
    _unmodifiableNavigableSet__T = typing.TypeVar('_unmodifiableNavigableSet__T')  # <T>
    @staticmethod
    def unmodifiableNavigableSet(navigableSet: 'NavigableSet'[_unmodifiableNavigableSet__T]) -> 'NavigableSet'[_unmodifiableNavigableSet__T]: ...
    _unmodifiableSet__T = typing.TypeVar('_unmodifiableSet__T')  # <T>
    @staticmethod
    def unmodifiableSet(set: 'Set'[_unmodifiableSet__T]) -> 'Set'[_unmodifiableSet__T]: ...
    _unmodifiableSortedMap__K = typing.TypeVar('_unmodifiableSortedMap__K')  # <K>
    _unmodifiableSortedMap__V = typing.TypeVar('_unmodifiableSortedMap__V')  # <V>
    @staticmethod
    def unmodifiableSortedMap(sortedMap: 'SortedMap'[_unmodifiableSortedMap__K, _unmodifiableSortedMap__V]) -> 'SortedMap'[_unmodifiableSortedMap__K, _unmodifiableSortedMap__V]: ...
    _unmodifiableSortedSet__T = typing.TypeVar('_unmodifiableSortedSet__T')  # <T>
    @staticmethod
    def unmodifiableSortedSet(sortedSet: 'SortedSet'[_unmodifiableSortedSet__T]) -> 'SortedSet'[_unmodifiableSortedSet__T]: ...

_Comparator__T = typing.TypeVar('_Comparator__T')  # <T>
class Comparator(typing.Generic[_Comparator__T]):
    def compare(self, t: _Comparator__T, t2: _Comparator__T) -> int: ...
    _comparing_0__T = typing.TypeVar('_comparing_0__T')  # <T>
    _comparing_0__U = typing.TypeVar('_comparing_0__U', bound=java.lang.Comparable)  # <U>
    _comparing_1__T = typing.TypeVar('_comparing_1__T')  # <T>
    _comparing_1__U = typing.TypeVar('_comparing_1__U')  # <U>
    @typing.overload
    @staticmethod
    def comparing(function: typing.Union[java.util.function.Function[_comparing_0__T, _comparing_0__U], typing.Callable[[_comparing_0__T], _comparing_0__U]]) -> 'Comparator'[_comparing_0__T]: ...
    @typing.overload
    @staticmethod
    def comparing(function: typing.Union[java.util.function.Function[_comparing_1__T, _comparing_1__U], typing.Callable[[_comparing_1__T], _comparing_1__U]], comparator: typing.Union['Comparator'[_comparing_1__U], typing.Callable[[_comparing_1__U, _comparing_1__U], int]]) -> 'Comparator'[_comparing_1__T]: ...
    _comparingDouble__T = typing.TypeVar('_comparingDouble__T')  # <T>
    @staticmethod
    def comparingDouble(toDoubleFunction: typing.Union[java.util.function.ToDoubleFunction[_comparingDouble__T], typing.Callable[[_comparingDouble__T], float]]) -> 'Comparator'[_comparingDouble__T]: ...
    _comparingInt__T = typing.TypeVar('_comparingInt__T')  # <T>
    @staticmethod
    def comparingInt(toIntFunction: typing.Union[java.util.function.ToIntFunction[_comparingInt__T], typing.Callable[[_comparingInt__T], int]]) -> 'Comparator'[_comparingInt__T]: ...
    _comparingLong__T = typing.TypeVar('_comparingLong__T')  # <T>
    @staticmethod
    def comparingLong(toLongFunction: typing.Union[java.util.function.ToLongFunction[_comparingLong__T], typing.Callable[[_comparingLong__T], int]]) -> 'Comparator'[_comparingLong__T]: ...
    def equals(self, object: typing.Any) -> bool: ...
    _naturalOrder__T = typing.TypeVar('_naturalOrder__T', bound=java.lang.Comparable)  # <T>
    @staticmethod
    def naturalOrder() -> 'Comparator'[_naturalOrder__T]: ...
    _nullsFirst__T = typing.TypeVar('_nullsFirst__T')  # <T>
    @staticmethod
    def nullsFirst(comparator: typing.Union['Comparator'[_nullsFirst__T], typing.Callable[[_nullsFirst__T, _nullsFirst__T], int]]) -> 'Comparator'[_nullsFirst__T]: ...
    _nullsLast__T = typing.TypeVar('_nullsLast__T')  # <T>
    @staticmethod
    def nullsLast(comparator: typing.Union['Comparator'[_nullsLast__T], typing.Callable[[_nullsLast__T, _nullsLast__T], int]]) -> 'Comparator'[_nullsLast__T]: ...
    _reverseOrder__T = typing.TypeVar('_reverseOrder__T', bound=java.lang.Comparable)  # <T>
    @staticmethod
    def reverseOrder() -> 'Comparator'[_reverseOrder__T]: ...
    def reversed(self) -> 'Comparator'[_Comparator__T]: ...
    _thenComparing_1__U = typing.TypeVar('_thenComparing_1__U', bound=java.lang.Comparable)  # <U>
    _thenComparing_2__U = typing.TypeVar('_thenComparing_2__U')  # <U>
    @typing.overload
    def thenComparing(self, comparator: typing.Union['Comparator'[_Comparator__T], typing.Callable[[_Comparator__T, _Comparator__T], int]]) -> 'Comparator'[_Comparator__T]: ...
    @typing.overload
    def thenComparing(self, function: typing.Union[java.util.function.Function[_Comparator__T, _thenComparing_1__U], typing.Callable[[_Comparator__T], _thenComparing_1__U]]) -> 'Comparator'[_Comparator__T]: ...
    @typing.overload
    def thenComparing(self, function: typing.Union[java.util.function.Function[_Comparator__T, _thenComparing_2__U], typing.Callable[[_Comparator__T], _thenComparing_2__U]], comparator: typing.Union['Comparator'[_thenComparing_2__U], typing.Callable[[_thenComparing_2__U, _thenComparing_2__U], int]]) -> 'Comparator'[_Comparator__T]: ...
    def thenComparingDouble(self, toDoubleFunction: typing.Union[java.util.function.ToDoubleFunction[_Comparator__T], typing.Callable[[_Comparator__T], float]]) -> 'Comparator'[_Comparator__T]: ...
    def thenComparingInt(self, toIntFunction: typing.Union[java.util.function.ToIntFunction[_Comparator__T], typing.Callable[[_Comparator__T], int]]) -> 'Comparator'[_Comparator__T]: ...
    def thenComparingLong(self, toLongFunction: typing.Union[java.util.function.ToLongFunction[_Comparator__T], typing.Callable[[_Comparator__T], int]]) -> 'Comparator'[_Comparator__T]: ...

class ConcurrentModificationException(java.lang.RuntimeException):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: str): ...
    @typing.overload
    def __init__(self, string: str, throwable: java.lang.Throwable): ...
    @typing.overload
    def __init__(self, throwable: java.lang.Throwable): ...

class Currency(java.io.Serializable):
    @staticmethod
    def getAvailableCurrencies() -> 'Set'['Currency']: ...
    def getCurrencyCode(self) -> str: ...
    def getDefaultFractionDigits(self) -> int: ...
    @typing.overload
    def getDisplayName(self) -> str: ...
    @typing.overload
    def getDisplayName(self, locale: 'Locale') -> str: ...
    @typing.overload
    @staticmethod
    def getInstance(string: str) -> 'Currency': ...
    @typing.overload
    @staticmethod
    def getInstance(locale: 'Locale') -> 'Currency': ...
    def getNumericCode(self) -> int: ...
    @typing.overload
    def getSymbol(self) -> str: ...
    @typing.overload
    def getSymbol(self, locale: 'Locale') -> str: ...
    def toString(self) -> str: ...

class Date(java.io.Serializable, java.lang.Cloneable, java.lang.Comparable['Date']):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int, int2: int, int3: int): ...
    @typing.overload
    def __init__(self, int: int, int2: int, int3: int, int4: int, int5: int): ...
    @typing.overload
    def __init__(self, int: int, int2: int, int3: int, int4: int, int5: int, int6: int): ...
    @typing.overload
    def __init__(self, string: str): ...
    @typing.overload
    def __init__(self, long: int): ...
    @staticmethod
    def UTC(int: int, int2: int, int3: int, int4: int, int5: int, int6: int) -> int: ...
    def after(self, date: 'Date') -> bool: ...
    def before(self, date: 'Date') -> bool: ...
    def clone(self) -> typing.Any: ...
    def compareTo(self, date: 'Date') -> int: ...
    def equals(self, object: typing.Any) -> bool: ...
    def getDate(self) -> int: ...
    def getDay(self) -> int: ...
    def getHours(self) -> int: ...
    def getMinutes(self) -> int: ...
    def getMonth(self) -> int: ...
    def getSeconds(self) -> int: ...
    def getTime(self) -> int: ...
    def getTimezoneOffset(self) -> int: ...
    def getYear(self) -> int: ...
    def hashCode(self) -> int: ...
    @staticmethod
    def parse(string: str) -> int: ...
    def setDate(self, int: int) -> None: ...
    def setHours(self, int: int) -> None: ...
    def setMinutes(self, int: int) -> None: ...
    def setMonth(self, int: int) -> None: ...
    def setSeconds(self, int: int) -> None: ...
    def setTime(self, long: int) -> None: ...
    def setYear(self, int: int) -> None: ...
    def toGMTString(self) -> str: ...
    def toInstant(self) -> java.time.Instant: ...
    def toLocaleString(self) -> str: ...
    def toString(self) -> str: ...

_Dictionary__K = typing.TypeVar('_Dictionary__K')  # <K>
_Dictionary__V = typing.TypeVar('_Dictionary__V')  # <V>
class Dictionary(typing.Generic[_Dictionary__K, _Dictionary__V]):
    def __init__(self): ...
    def elements(self) -> 'Enumeration'[_Dictionary__V]: ...
    def get(self, object: typing.Any) -> _Dictionary__V: ...
    def isEmpty(self) -> bool: ...
    def keys(self) -> 'Enumeration'[_Dictionary__K]: ...
    def put(self, k: _Dictionary__K, v: _Dictionary__V) -> _Dictionary__V: ...
    def remove(self, object: typing.Any) -> _Dictionary__V: ...
    def size(self) -> int: ...

class DoubleSummaryStatistics(java.util.function.DoubleConsumer):
    def __init__(self): ...
    def accept(self, double: float) -> None: ...
    def combine(self, doubleSummaryStatistics: 'DoubleSummaryStatistics') -> None: ...
    def getAverage(self) -> float: ...
    def getCount(self) -> int: ...
    def getMax(self) -> float: ...
    def getMin(self) -> float: ...
    def getSum(self) -> float: ...
    def toString(self) -> str: ...

class EmptyStackException(java.lang.RuntimeException):
    def __init__(self): ...

_Enumeration__E = typing.TypeVar('_Enumeration__E')  # <E>
class Enumeration(typing.Generic[_Enumeration__E], _JEnumeration[_Enumeration__E]):
    def hasMoreElements(self) -> bool: ...
    def nextElement(self) -> _Enumeration__E: ...

class EventListener: ...

class EventObject(java.io.Serializable):
    def __init__(self, object: typing.Any): ...
    def getSource(self) -> typing.Any: ...
    def toString(self) -> str: ...

class Formattable:
    def formatTo(self, formatter: 'Formatter', int: int, int2: int, int3: int) -> None: ...

class FormattableFlags:
    LEFT_JUSTIFY: typing.ClassVar[int] = ...
    UPPERCASE: typing.ClassVar[int] = ...
    ALTERNATE: typing.ClassVar[int] = ...

class Formatter(java.io.Closeable, java.io.Flushable):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, file: typing.Union[java.io.File, jpype.protocol.SupportsPath]): ...
    @typing.overload
    def __init__(self, file: typing.Union[java.io.File, jpype.protocol.SupportsPath], string: str): ...
    @typing.overload
    def __init__(self, file: typing.Union[java.io.File, jpype.protocol.SupportsPath], string: str, locale: 'Locale'): ...
    @typing.overload
    def __init__(self, outputStream: java.io.OutputStream): ...
    @typing.overload
    def __init__(self, outputStream: java.io.OutputStream, string: str): ...
    @typing.overload
    def __init__(self, outputStream: java.io.OutputStream, string: str, locale: 'Locale'): ...
    @typing.overload
    def __init__(self, printStream: java.io.PrintStream): ...
    @typing.overload
    def __init__(self, appendable: java.lang.Appendable): ...
    @typing.overload
    def __init__(self, appendable: java.lang.Appendable, locale: 'Locale'): ...
    @typing.overload
    def __init__(self, string: str): ...
    @typing.overload
    def __init__(self, string: str, string2: str): ...
    @typing.overload
    def __init__(self, string: str, string2: str, locale: 'Locale'): ...
    @typing.overload
    def __init__(self, locale: 'Locale'): ...
    def close(self) -> None: ...
    def flush(self) -> None: ...
    @typing.overload
    def format(self, string: str, objectArray: typing.List[typing.Any]) -> 'Formatter': ...
    @typing.overload
    def format(self, locale: 'Locale', string: str, objectArray: typing.List[typing.Any]) -> 'Formatter': ...
    def ioException(self) -> java.io.IOException: ...
    def locale(self) -> 'Locale': ...
    def out(self) -> java.lang.Appendable: ...
    def toString(self) -> str: ...
    class BigDecimalLayoutForm(java.lang.Enum['Formatter.BigDecimalLayoutForm']):
        SCIENTIFIC: typing.ClassVar['Formatter.BigDecimalLayoutForm'] = ...
        DECIMAL_FLOAT: typing.ClassVar['Formatter.BigDecimalLayoutForm'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'Formatter.BigDecimalLayoutForm': ...
        @staticmethod
        def values() -> typing.List['Formatter.BigDecimalLayoutForm']: ...

class FormatterClosedException(java.lang.IllegalStateException):
    def __init__(self): ...

class IllegalFormatException(java.lang.IllegalArgumentException): ...

class IllformedLocaleException(java.lang.RuntimeException):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: str): ...
    @typing.overload
    def __init__(self, string: str, int: int): ...
    def getErrorIndex(self) -> int: ...

class IntSummaryStatistics(java.util.function.IntConsumer):
    def __init__(self): ...
    def accept(self, int: int) -> None: ...
    def combine(self, intSummaryStatistics: 'IntSummaryStatistics') -> None: ...
    def getAverage(self) -> float: ...
    def getCount(self) -> int: ...
    def getMax(self) -> int: ...
    def getMin(self) -> int: ...
    def getSum(self) -> int: ...
    def toString(self) -> str: ...

class InvalidPropertiesFormatException(java.io.IOException):
    @typing.overload
    def __init__(self, string: str): ...
    @typing.overload
    def __init__(self, throwable: java.lang.Throwable): ...

_Iterator__E = typing.TypeVar('_Iterator__E')  # <E>
class Iterator(typing.Generic[_Iterator__E], _JIterator[_Iterator__E]):
    def forEachRemaining(self, consumer: typing.Union[java.util.function.Consumer[_Iterator__E], typing.Callable[[_Iterator__E], None]]) -> None: ...
    def hasNext(self) -> bool: ...
    def next(self) -> _Iterator__E: ...
    def remove(self) -> None: ...

class Locale(java.lang.Cloneable, java.io.Serializable):
    ENGLISH: typing.ClassVar['Locale'] = ...
    FRENCH: typing.ClassVar['Locale'] = ...
    GERMAN: typing.ClassVar['Locale'] = ...
    ITALIAN: typing.ClassVar['Locale'] = ...
    JAPANESE: typing.ClassVar['Locale'] = ...
    KOREAN: typing.ClassVar['Locale'] = ...
    CHINESE: typing.ClassVar['Locale'] = ...
    SIMPLIFIED_CHINESE: typing.ClassVar['Locale'] = ...
    TRADITIONAL_CHINESE: typing.ClassVar['Locale'] = ...
    FRANCE: typing.ClassVar['Locale'] = ...
    GERMANY: typing.ClassVar['Locale'] = ...
    ITALY: typing.ClassVar['Locale'] = ...
    JAPAN: typing.ClassVar['Locale'] = ...
    KOREA: typing.ClassVar['Locale'] = ...
    CHINA: typing.ClassVar['Locale'] = ...
    PRC: typing.ClassVar['Locale'] = ...
    TAIWAN: typing.ClassVar['Locale'] = ...
    UK: typing.ClassVar['Locale'] = ...
    US: typing.ClassVar['Locale'] = ...
    CANADA: typing.ClassVar['Locale'] = ...
    CANADA_FRENCH: typing.ClassVar['Locale'] = ...
    ROOT: typing.ClassVar['Locale'] = ...
    PRIVATE_USE_EXTENSION: typing.ClassVar[str] = ...
    UNICODE_LOCALE_EXTENSION: typing.ClassVar[str] = ...
    @typing.overload
    def __init__(self, string: str): ...
    @typing.overload
    def __init__(self, string: str, string2: str): ...
    @typing.overload
    def __init__(self, string: str, string2: str, string3: str): ...
    def clone(self) -> typing.Any: ...
    def equals(self, object: typing.Any) -> bool: ...
    @typing.overload
    @staticmethod
    def filter(list: 'List'['Locale.LanguageRange'], collection: typing.Union[Collection['Locale'], typing.Sequence['Locale'], typing.Set['Locale']]) -> 'List'['Locale']: ...
    @typing.overload
    @staticmethod
    def filter(list: 'List'['Locale.LanguageRange'], collection: typing.Union[Collection['Locale'], typing.Sequence['Locale'], typing.Set['Locale']], filteringMode: 'Locale.FilteringMode') -> 'List'['Locale']: ...
    @typing.overload
    @staticmethod
    def filterTags(list: 'List'['Locale.LanguageRange'], collection: typing.Union[Collection[str], typing.Sequence[str], typing.Set[str]]) -> 'List'[str]: ...
    @typing.overload
    @staticmethod
    def filterTags(list: 'List'['Locale.LanguageRange'], collection: typing.Union[Collection[str], typing.Sequence[str], typing.Set[str]], filteringMode: 'Locale.FilteringMode') -> 'List'[str]: ...
    @staticmethod
    def forLanguageTag(string: str) -> 'Locale': ...
    @staticmethod
    def getAvailableLocales() -> typing.List['Locale']: ...
    def getCountry(self) -> str: ...
    @typing.overload
    @staticmethod
    def getDefault() -> 'Locale': ...
    @typing.overload
    @staticmethod
    def getDefault(category: 'Locale.Category') -> 'Locale': ...
    @typing.overload
    def getDisplayCountry(self) -> str: ...
    @typing.overload
    def getDisplayCountry(self, locale: 'Locale') -> str: ...
    @typing.overload
    def getDisplayLanguage(self) -> str: ...
    @typing.overload
    def getDisplayLanguage(self, locale: 'Locale') -> str: ...
    @typing.overload
    def getDisplayName(self) -> str: ...
    @typing.overload
    def getDisplayName(self, locale: 'Locale') -> str: ...
    @typing.overload
    def getDisplayScript(self) -> str: ...
    @typing.overload
    def getDisplayScript(self, locale: 'Locale') -> str: ...
    @typing.overload
    def getDisplayVariant(self) -> str: ...
    @typing.overload
    def getDisplayVariant(self, locale: 'Locale') -> str: ...
    def getExtension(self, char: str) -> str: ...
    def getExtensionKeys(self) -> 'Set'[str]: ...
    def getISO3Country(self) -> str: ...
    def getISO3Language(self) -> str: ...
    @staticmethod
    def getISOCountries() -> typing.List[str]: ...
    @staticmethod
    def getISOLanguages() -> typing.List[str]: ...
    def getLanguage(self) -> str: ...
    def getScript(self) -> str: ...
    def getUnicodeLocaleAttributes(self) -> 'Set'[str]: ...
    def getUnicodeLocaleKeys(self) -> 'Set'[str]: ...
    def getUnicodeLocaleType(self, string: str) -> str: ...
    def getVariant(self) -> str: ...
    def hasExtensions(self) -> bool: ...
    def hashCode(self) -> int: ...
    @staticmethod
    def lookup(list: 'List'['Locale.LanguageRange'], collection: typing.Union[Collection['Locale'], typing.Sequence['Locale'], typing.Set['Locale']]) -> 'Locale': ...
    @staticmethod
    def lookupTag(list: 'List'['Locale.LanguageRange'], collection: typing.Union[Collection[str], typing.Sequence[str], typing.Set[str]]) -> str: ...
    @typing.overload
    @staticmethod
    def setDefault(category: 'Locale.Category', locale: 'Locale') -> None: ...
    @typing.overload
    @staticmethod
    def setDefault(locale: 'Locale') -> None: ...
    def stripExtensions(self) -> 'Locale': ...
    def toLanguageTag(self) -> str: ...
    def toString(self) -> str: ...
    class Builder:
        def __init__(self): ...
        def addUnicodeLocaleAttribute(self, string: str) -> 'Locale.Builder': ...
        def build(self) -> 'Locale': ...
        def clear(self) -> 'Locale.Builder': ...
        def clearExtensions(self) -> 'Locale.Builder': ...
        def removeUnicodeLocaleAttribute(self, string: str) -> 'Locale.Builder': ...
        def setExtension(self, char: str, string: str) -> 'Locale.Builder': ...
        def setLanguage(self, string: str) -> 'Locale.Builder': ...
        def setLanguageTag(self, string: str) -> 'Locale.Builder': ...
        def setLocale(self, locale: 'Locale') -> 'Locale.Builder': ...
        def setRegion(self, string: str) -> 'Locale.Builder': ...
        def setScript(self, string: str) -> 'Locale.Builder': ...
        def setUnicodeLocaleKeyword(self, string: str, string2: str) -> 'Locale.Builder': ...
        def setVariant(self, string: str) -> 'Locale.Builder': ...
    class Category(java.lang.Enum['Locale.Category']):
        DISPLAY: typing.ClassVar['Locale.Category'] = ...
        FORMAT: typing.ClassVar['Locale.Category'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'Locale.Category': ...
        @staticmethod
        def values() -> typing.List['Locale.Category']: ...
    class FilteringMode(java.lang.Enum['Locale.FilteringMode']):
        AUTOSELECT_FILTERING: typing.ClassVar['Locale.FilteringMode'] = ...
        EXTENDED_FILTERING: typing.ClassVar['Locale.FilteringMode'] = ...
        IGNORE_EXTENDED_RANGES: typing.ClassVar['Locale.FilteringMode'] = ...
        MAP_EXTENDED_RANGES: typing.ClassVar['Locale.FilteringMode'] = ...
        REJECT_EXTENDED_RANGES: typing.ClassVar['Locale.FilteringMode'] = ...
        _valueOf_0__T = typing.TypeVar('_valueOf_0__T', bound=java.lang.Enum)  # <T>
        @typing.overload
        @staticmethod
        def valueOf(class_: typing.Type[_valueOf_0__T], string: str) -> _valueOf_0__T: ...
        @typing.overload
        @staticmethod
        def valueOf(string: str) -> 'Locale.FilteringMode': ...
        @staticmethod
        def values() -> typing.List['Locale.FilteringMode']: ...
    class LanguageRange:
        MAX_WEIGHT: typing.ClassVar[float] = ...
        MIN_WEIGHT: typing.ClassVar[float] = ...
        @typing.overload
        def __init__(self, string: str): ...
        @typing.overload
        def __init__(self, string: str, double: float): ...
        def equals(self, object: typing.Any) -> bool: ...
        def getRange(self) -> str: ...
        def getWeight(self) -> float: ...
        def hashCode(self) -> int: ...
        @staticmethod
        def mapEquivalents(list: 'List'['Locale.LanguageRange'], map: typing.Union['Map'[str, 'List'[str]], typing.Mapping[str, 'List'[str]]]) -> 'List'['Locale.LanguageRange']: ...
        @typing.overload
        @staticmethod
        def parse(string: str) -> 'List'['Locale.LanguageRange']: ...
        @typing.overload
        @staticmethod
        def parse(string: str, map: typing.Union['Map'[str, 'List'[str]], typing.Mapping[str, 'List'[str]]]) -> 'List'['Locale.LanguageRange']: ...

class LongSummaryStatistics(java.util.function.LongConsumer, java.util.function.IntConsumer):
    def __init__(self): ...
    @typing.overload
    def accept(self, int: int) -> None: ...
    @typing.overload
    def accept(self, long: int) -> None: ...
    def combine(self, longSummaryStatistics: 'LongSummaryStatistics') -> None: ...
    def getAverage(self) -> float: ...
    def getCount(self) -> int: ...
    def getMax(self) -> int: ...
    def getMin(self) -> int: ...
    def getSum(self) -> int: ...
    def toString(self) -> str: ...

_Map__Entry__K = typing.TypeVar('_Map__Entry__K')  # <K>
_Map__Entry__V = typing.TypeVar('_Map__Entry__V')  # <V>
_Map__K = typing.TypeVar('_Map__K')  # <K>
_Map__V = typing.TypeVar('_Map__V')  # <V>
class Map(typing.Generic[_Map__K, _Map__V], _JMap[_Map__K, _Map__V]):
    def clear(self) -> None: ...
    def compute(self, k: _Map__K, biFunction: typing.Union[java.util.function.BiFunction[_Map__K, _Map__V, _Map__V], typing.Callable[[_Map__K, _Map__V], _Map__V]]) -> _Map__V: ...
    def computeIfAbsent(self, k: _Map__K, function: typing.Union[java.util.function.Function[_Map__K, _Map__V], typing.Callable[[_Map__K], _Map__V]]) -> _Map__V: ...
    def computeIfPresent(self, k: _Map__K, biFunction: typing.Union[java.util.function.BiFunction[_Map__K, _Map__V, _Map__V], typing.Callable[[_Map__K, _Map__V], _Map__V]]) -> _Map__V: ...
    def containsKey(self, object: typing.Any) -> bool: ...
    def containsValue(self, object: typing.Any) -> bool: ...
    def entrySet(self) -> 'Set'['Map.Entry'[_Map__K, _Map__V]]: ...
    def equals(self, object: typing.Any) -> bool: ...
    def forEach(self, biConsumer: typing.Union[java.util.function.BiConsumer[_Map__K, _Map__V], typing.Callable[[_Map__K, _Map__V], None]]) -> None: ...
    def get(self, object: typing.Any) -> _Map__V: ...
    def getOrDefault(self, object: typing.Any, v: _Map__V) -> _Map__V: ...
    def hashCode(self) -> int: ...
    def isEmpty(self) -> bool: ...
    def keySet(self) -> 'Set'[_Map__K]: ...
    def merge(self, k: _Map__K, v: _Map__V, biFunction: typing.Union[java.util.function.BiFunction[_Map__V, _Map__V, _Map__V], typing.Callable[[_Map__V, _Map__V], _Map__V]]) -> _Map__V: ...
    def put(self, k: _Map__K, v: _Map__V) -> _Map__V: ...
    def putAll(self, map: typing.Union['Map'[_Map__K, _Map__V], typing.Mapping[_Map__K, _Map__V]]) -> None: ...
    def putIfAbsent(self, k: _Map__K, v: _Map__V) -> _Map__V: ...
    @typing.overload
    def remove(self, object: typing.Any) -> _Map__V: ...
    @typing.overload
    def remove(self, object: typing.Any, object2: typing.Any) -> bool: ...
    @typing.overload
    def replace(self, k: _Map__K, v: _Map__V, v2: _Map__V) -> bool: ...
    @typing.overload
    def replace(self, k: _Map__K, v: _Map__V) -> _Map__V: ...
    def replaceAll(self, biFunction: typing.Union[java.util.function.BiFunction[_Map__K, _Map__V, _Map__V], typing.Callable[[_Map__K, _Map__V], _Map__V]]) -> None: ...
    def size(self) -> int: ...
    def values(self) -> Collection[_Map__V]: ...
    class Entry(typing.Generic[_Map__Entry__K, _Map__Entry__V], _JMapEntry[_Map__Entry__K, _Map__Entry__V]):
        _comparingByKey_0__K = typing.TypeVar('_comparingByKey_0__K', bound=java.lang.Comparable)  # <K>
        _comparingByKey_0__V = typing.TypeVar('_comparingByKey_0__V')  # <V>
        _comparingByKey_1__K = typing.TypeVar('_comparingByKey_1__K')  # <K>
        _comparingByKey_1__V = typing.TypeVar('_comparingByKey_1__V')  # <V>
        @typing.overload
        @staticmethod
        def comparingByKey() -> Comparator['Map.Entry'[_comparingByKey_0__K, _comparingByKey_0__V]]: ...
        @typing.overload
        @staticmethod
        def comparingByKey(comparator: typing.Union[Comparator[_comparingByKey_1__K], typing.Callable[[_comparingByKey_1__K, _comparingByKey_1__K], int]]) -> Comparator['Map.Entry'[_comparingByKey_1__K, _comparingByKey_1__V]]: ...
        _comparingByValue_0__K = typing.TypeVar('_comparingByValue_0__K')  # <K>
        _comparingByValue_0__V = typing.TypeVar('_comparingByValue_0__V', bound=java.lang.Comparable)  # <V>
        _comparingByValue_1__K = typing.TypeVar('_comparingByValue_1__K')  # <K>
        _comparingByValue_1__V = typing.TypeVar('_comparingByValue_1__V')  # <V>
        @typing.overload
        @staticmethod
        def comparingByValue() -> Comparator['Map.Entry'[_comparingByValue_0__K, _comparingByValue_0__V]]: ...
        @typing.overload
        @staticmethod
        def comparingByValue(comparator: typing.Union[Comparator[_comparingByValue_1__V], typing.Callable[[_comparingByValue_1__V, _comparingByValue_1__V], int]]) -> Comparator['Map.Entry'[_comparingByValue_1__K, _comparingByValue_1__V]]: ...
        def equals(self, object: typing.Any) -> bool: ...
        def getKey(self) -> _Map__Entry__K: ...
        def getValue(self) -> _Map__Entry__V: ...
        def hashCode(self) -> int: ...
        def setValue(self, v: _Map__Entry__V) -> _Map__Entry__V: ...

class MissingResourceException(java.lang.RuntimeException):
    def __init__(self, string: str, string2: str, string3: str): ...
    def getClassName(self) -> str: ...
    def getKey(self) -> str: ...

class NoSuchElementException(java.lang.RuntimeException):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: str): ...

class Objects:
    _compare__T = typing.TypeVar('_compare__T')  # <T>
    @staticmethod
    def compare(t: _compare__T, t2: _compare__T, comparator: typing.Union[Comparator[_compare__T], typing.Callable[[_compare__T, _compare__T], int]]) -> int: ...
    @staticmethod
    def deepEquals(object: typing.Any, object2: typing.Any) -> bool: ...
    @typing.overload
    def equals(self, object: typing.Any) -> bool: ...
    @typing.overload
    @staticmethod
    def equals(object: typing.Any, object2: typing.Any) -> bool: ...
    @staticmethod
    def hash(objectArray: typing.List[typing.Any]) -> int: ...
    @typing.overload
    def hashCode(self) -> int: ...
    @typing.overload
    @staticmethod
    def hashCode(object: typing.Any) -> int: ...
    @staticmethod
    def isNull(object: typing.Any) -> bool: ...
    @staticmethod
    def nonNull(object: typing.Any) -> bool: ...
    _requireNonNull_0__T = typing.TypeVar('_requireNonNull_0__T')  # <T>
    _requireNonNull_1__T = typing.TypeVar('_requireNonNull_1__T')  # <T>
    _requireNonNull_2__T = typing.TypeVar('_requireNonNull_2__T')  # <T>
    @typing.overload
    @staticmethod
    def requireNonNull(t: _requireNonNull_0__T) -> _requireNonNull_0__T: ...
    @typing.overload
    @staticmethod
    def requireNonNull(t: _requireNonNull_1__T, string: str) -> _requireNonNull_1__T: ...
    @typing.overload
    @staticmethod
    def requireNonNull(t: _requireNonNull_2__T, supplier: typing.Union[java.util.function.Supplier[str], typing.Callable[[], str]]) -> _requireNonNull_2__T: ...
    @typing.overload
    def toString(self) -> str: ...
    @typing.overload
    @staticmethod
    def toString(object: typing.Any) -> str: ...
    @typing.overload
    @staticmethod
    def toString(object: typing.Any, string: str) -> str: ...

class Observable:
    def __init__(self): ...
    def addObserver(self, observer: 'Observer') -> None: ...
    def countObservers(self) -> int: ...
    def deleteObserver(self, observer: 'Observer') -> None: ...
    def deleteObservers(self) -> None: ...
    def hasChanged(self) -> bool: ...
    @typing.overload
    def notifyObservers(self) -> None: ...
    @typing.overload
    def notifyObservers(self, object: typing.Any) -> None: ...

class Observer:
    def update(self, observable: Observable, object: typing.Any) -> None: ...

_Optional__T = typing.TypeVar('_Optional__T')  # <T>
class Optional(typing.Generic[_Optional__T]):
    _empty__T = typing.TypeVar('_empty__T')  # <T>
    @staticmethod
    def empty() -> 'Optional'[_empty__T]: ...
    def equals(self, object: typing.Any) -> bool: ...
    def filter(self, predicate: typing.Union[java.util.function.Predicate[_Optional__T], typing.Callable[[_Optional__T], bool]]) -> 'Optional'[_Optional__T]: ...
    _flatMap__U = typing.TypeVar('_flatMap__U')  # <U>
    def flatMap(self, function: typing.Union[java.util.function.Function[_Optional__T, 'Optional'[_flatMap__U]], typing.Callable[[_Optional__T], 'Optional'[_flatMap__U]]]) -> 'Optional'[_flatMap__U]: ...
    def get(self) -> _Optional__T: ...
    def hashCode(self) -> int: ...
    def ifPresent(self, consumer: typing.Union[java.util.function.Consumer[_Optional__T], typing.Callable[[_Optional__T], None]]) -> None: ...
    def isPresent(self) -> bool: ...
    _map__U = typing.TypeVar('_map__U')  # <U>
    def map(self, function: typing.Union[java.util.function.Function[_Optional__T, _map__U], typing.Callable[[_Optional__T], _map__U]]) -> 'Optional'[_map__U]: ...
    _of__T = typing.TypeVar('_of__T')  # <T>
    @staticmethod
    def of(t: _of__T) -> 'Optional'[_of__T]: ...
    _ofNullable__T = typing.TypeVar('_ofNullable__T')  # <T>
    @staticmethod
    def ofNullable(t: _ofNullable__T) -> 'Optional'[_ofNullable__T]: ...
    def orElse(self, t: _Optional__T) -> _Optional__T: ...
    def orElseGet(self, supplier: typing.Union[java.util.function.Supplier[_Optional__T], typing.Callable[[], _Optional__T]]) -> _Optional__T: ...
    _orElseThrow__X = typing.TypeVar('_orElseThrow__X', bound=java.lang.Throwable)  # <X>
    def orElseThrow(self, supplier: typing.Union[java.util.function.Supplier[_orElseThrow__X], typing.Callable[[], _orElseThrow__X]]) -> _Optional__T: ...
    def toString(self) -> str: ...

class OptionalDouble:
    @staticmethod
    def empty() -> 'OptionalDouble': ...
    def equals(self, object: typing.Any) -> bool: ...
    def getAsDouble(self) -> float: ...
    def hashCode(self) -> int: ...
    def ifPresent(self, doubleConsumer: typing.Union[java.util.function.DoubleConsumer, typing.Callable]) -> None: ...
    def isPresent(self) -> bool: ...
    @staticmethod
    def of(double: float) -> 'OptionalDouble': ...
    def orElse(self, double: float) -> float: ...
    def orElseGet(self, doubleSupplier: typing.Union[java.util.function.DoubleSupplier, typing.Callable]) -> float: ...
    _orElseThrow__X = typing.TypeVar('_orElseThrow__X', bound=java.lang.Throwable)  # <X>
    def orElseThrow(self, supplier: typing.Union[java.util.function.Supplier[_orElseThrow__X], typing.Callable[[], _orElseThrow__X]]) -> float: ...
    def toString(self) -> str: ...

class OptionalInt:
    @staticmethod
    def empty() -> 'OptionalInt': ...
    def equals(self, object: typing.Any) -> bool: ...
    def getAsInt(self) -> int: ...
    def hashCode(self) -> int: ...
    def ifPresent(self, intConsumer: typing.Union[java.util.function.IntConsumer, typing.Callable]) -> None: ...
    def isPresent(self) -> bool: ...
    @staticmethod
    def of(int: int) -> 'OptionalInt': ...
    def orElse(self, int: int) -> int: ...
    def orElseGet(self, intSupplier: typing.Union[java.util.function.IntSupplier, typing.Callable]) -> int: ...
    _orElseThrow__X = typing.TypeVar('_orElseThrow__X', bound=java.lang.Throwable)  # <X>
    def orElseThrow(self, supplier: typing.Union[java.util.function.Supplier[_orElseThrow__X], typing.Callable[[], _orElseThrow__X]]) -> int: ...
    def toString(self) -> str: ...

class OptionalLong:
    @staticmethod
    def empty() -> 'OptionalLong': ...
    def equals(self, object: typing.Any) -> bool: ...
    def getAsLong(self) -> int: ...
    def hashCode(self) -> int: ...
    def ifPresent(self, longConsumer: typing.Union[java.util.function.LongConsumer, typing.Callable]) -> None: ...
    def isPresent(self) -> bool: ...
    @staticmethod
    def of(long: int) -> 'OptionalLong': ...
    def orElse(self, long: int) -> int: ...
    def orElseGet(self, longSupplier: typing.Union[java.util.function.LongSupplier, typing.Callable]) -> int: ...
    _orElseThrow__X = typing.TypeVar('_orElseThrow__X', bound=java.lang.Throwable)  # <X>
    def orElseThrow(self, supplier: typing.Union[java.util.function.Supplier[_orElseThrow__X], typing.Callable[[], _orElseThrow__X]]) -> int: ...
    def toString(self) -> str: ...

class PropertyPermission(java.security.BasicPermission):
    def __init__(self, string: str, string2: str): ...
    def equals(self, object: typing.Any) -> bool: ...
    def getActions(self) -> str: ...
    def hashCode(self) -> int: ...
    def implies(self, permission: java.security.Permission) -> bool: ...
    def newPermissionCollection(self) -> java.security.PermissionCollection: ...

class Random(java.io.Serializable):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, long: int): ...
    @typing.overload
    def doubles(self) -> java.util.stream.DoubleStream: ...
    @typing.overload
    def doubles(self, double: float, double2: float) -> java.util.stream.DoubleStream: ...
    @typing.overload
    def doubles(self, long: int) -> java.util.stream.DoubleStream: ...
    @typing.overload
    def doubles(self, long: int, double: float, double2: float) -> java.util.stream.DoubleStream: ...
    @typing.overload
    def ints(self) -> java.util.stream.IntStream: ...
    @typing.overload
    def ints(self, int: int, int2: int) -> java.util.stream.IntStream: ...
    @typing.overload
    def ints(self, long: int) -> java.util.stream.IntStream: ...
    @typing.overload
    def ints(self, long: int, int: int, int2: int) -> java.util.stream.IntStream: ...
    @typing.overload
    def longs(self) -> java.util.stream.LongStream: ...
    @typing.overload
    def longs(self, long: int) -> java.util.stream.LongStream: ...
    @typing.overload
    def longs(self, long: int, long2: int) -> java.util.stream.LongStream: ...
    @typing.overload
    def longs(self, long: int, long2: int, long3: int) -> java.util.stream.LongStream: ...
    def nextBoolean(self) -> bool: ...
    def nextBytes(self, byteArray: typing.List[int]) -> None: ...
    def nextDouble(self) -> float: ...
    def nextFloat(self) -> float: ...
    def nextGaussian(self) -> float: ...
    @typing.overload
    def nextInt(self) -> int: ...
    @typing.overload
    def nextInt(self, int: int) -> int: ...
    def nextLong(self) -> int: ...
    def setSeed(self, long: int) -> None: ...

class RandomAccess: ...

class ResourceBundle:
    def __init__(self): ...
    @typing.overload
    @staticmethod
    def clearCache() -> None: ...
    @typing.overload
    @staticmethod
    def clearCache(classLoader: java.lang.ClassLoader) -> None: ...
    def containsKey(self, string: str) -> bool: ...
    def getBaseBundleName(self) -> str: ...
    @typing.overload
    @staticmethod
    def getBundle(string: str) -> 'ResourceBundle': ...
    @typing.overload
    @staticmethod
    def getBundle(string: str, locale: Locale) -> 'ResourceBundle': ...
    @typing.overload
    @staticmethod
    def getBundle(string: str, locale: Locale, control: 'ResourceBundle.Control') -> 'ResourceBundle': ...
    @typing.overload
    @staticmethod
    def getBundle(string: str, control: 'ResourceBundle.Control') -> 'ResourceBundle': ...
    @typing.overload
    @staticmethod
    def getBundle(string: str, locale: Locale, classLoader: java.lang.ClassLoader) -> 'ResourceBundle': ...
    @typing.overload
    @staticmethod
    def getBundle(string: str, locale: Locale, classLoader: java.lang.ClassLoader, control: 'ResourceBundle.Control') -> 'ResourceBundle': ...
    def getKeys(self) -> Enumeration[str]: ...
    def getLocale(self) -> Locale: ...
    def getObject(self, string: str) -> typing.Any: ...
    def getString(self, string: str) -> str: ...
    def getStringArray(self, string: str) -> typing.List[str]: ...
    def keySet(self) -> 'Set'[str]: ...
    class Control:
        FORMAT_DEFAULT: typing.ClassVar['List'] = ...
        FORMAT_CLASS: typing.ClassVar['List'] = ...
        FORMAT_PROPERTIES: typing.ClassVar['List'] = ...
        TTL_DONT_CACHE: typing.ClassVar[int] = ...
        TTL_NO_EXPIRATION_CONTROL: typing.ClassVar[int] = ...
        def getCandidateLocales(self, string: str, locale: Locale) -> 'List'[Locale]: ...
        @staticmethod
        def getControl(list: 'List'[str]) -> 'ResourceBundle.Control': ...
        def getFallbackLocale(self, string: str, locale: Locale) -> Locale: ...
        def getFormats(self, string: str) -> 'List'[str]: ...
        @staticmethod
        def getNoFallbackControl(list: 'List'[str]) -> 'ResourceBundle.Control': ...
        def getTimeToLive(self, string: str, locale: Locale) -> int: ...
        def needsReload(self, string: str, locale: Locale, string2: str, classLoader: java.lang.ClassLoader, resourceBundle: 'ResourceBundle', long: int) -> bool: ...
        def newBundle(self, string: str, locale: Locale, string2: str, classLoader: java.lang.ClassLoader, boolean: bool) -> 'ResourceBundle': ...
        def toBundleName(self, string: str, locale: Locale) -> str: ...
        def toResourceName(self, string: str, string2: str) -> str: ...

class ServiceConfigurationError(java.lang.Error):
    @typing.overload
    def __init__(self, string: str): ...
    @typing.overload
    def __init__(self, string: str, throwable: java.lang.Throwable): ...

_ServiceLoader__S = typing.TypeVar('_ServiceLoader__S')  # <S>
class ServiceLoader(java.lang.Iterable[_ServiceLoader__S], typing.Generic[_ServiceLoader__S]):
    def iterator(self) -> Iterator[_ServiceLoader__S]: ...
    _load_0__S = typing.TypeVar('_load_0__S')  # <S>
    _load_1__S = typing.TypeVar('_load_1__S')  # <S>
    @typing.overload
    @staticmethod
    def load(class_: typing.Type[_load_0__S]) -> 'ServiceLoader'[_load_0__S]: ...
    @typing.overload
    @staticmethod
    def load(class_: typing.Type[_load_1__S], classLoader: java.lang.ClassLoader) -> 'ServiceLoader'[_load_1__S]: ...
    _loadInstalled__S = typing.TypeVar('_loadInstalled__S')  # <S>
    @staticmethod
    def loadInstalled(class_: typing.Type[_loadInstalled__S]) -> 'ServiceLoader'[_loadInstalled__S]: ...
    def reload(self) -> None: ...
    def toString(self) -> str: ...

class SplittableRandom:
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, long: int): ...
    @typing.overload
    def doubles(self) -> java.util.stream.DoubleStream: ...
    @typing.overload
    def doubles(self, double: float, double2: float) -> java.util.stream.DoubleStream: ...
    @typing.overload
    def doubles(self, long: int) -> java.util.stream.DoubleStream: ...
    @typing.overload
    def doubles(self, long: int, double: float, double2: float) -> java.util.stream.DoubleStream: ...
    @typing.overload
    def ints(self) -> java.util.stream.IntStream: ...
    @typing.overload
    def ints(self, int: int, int2: int) -> java.util.stream.IntStream: ...
    @typing.overload
    def ints(self, long: int) -> java.util.stream.IntStream: ...
    @typing.overload
    def ints(self, long: int, int: int, int2: int) -> java.util.stream.IntStream: ...
    @typing.overload
    def longs(self) -> java.util.stream.LongStream: ...
    @typing.overload
    def longs(self, long: int) -> java.util.stream.LongStream: ...
    @typing.overload
    def longs(self, long: int, long2: int) -> java.util.stream.LongStream: ...
    @typing.overload
    def longs(self, long: int, long2: int, long3: int) -> java.util.stream.LongStream: ...
    def nextBoolean(self) -> bool: ...
    @typing.overload
    def nextDouble(self) -> float: ...
    @typing.overload
    def nextDouble(self, double: float) -> float: ...
    @typing.overload
    def nextDouble(self, double: float, double2: float) -> float: ...
    @typing.overload
    def nextInt(self) -> int: ...
    @typing.overload
    def nextInt(self, int: int) -> int: ...
    @typing.overload
    def nextInt(self, int: int, int2: int) -> int: ...
    @typing.overload
    def nextLong(self) -> int: ...
    @typing.overload
    def nextLong(self, long: int) -> int: ...
    @typing.overload
    def nextLong(self, long: int, long2: int) -> int: ...
    def split(self) -> 'SplittableRandom': ...

class StringJoiner:
    @typing.overload
    def __init__(self, charSequence: typing.Union[java.lang.CharSequence, str]): ...
    @typing.overload
    def __init__(self, charSequence: typing.Union[java.lang.CharSequence, str], charSequence2: typing.Union[java.lang.CharSequence, str], charSequence3: typing.Union[java.lang.CharSequence, str]): ...
    def add(self, charSequence: typing.Union[java.lang.CharSequence, str]) -> 'StringJoiner': ...
    def length(self) -> int: ...
    def merge(self, stringJoiner: 'StringJoiner') -> 'StringJoiner': ...
    def setEmptyValue(self, charSequence: typing.Union[java.lang.CharSequence, str]) -> 'StringJoiner': ...
    def toString(self) -> str: ...

class TimeZone(java.io.Serializable, java.lang.Cloneable):
    SHORT: typing.ClassVar[int] = ...
    LONG: typing.ClassVar[int] = ...
    def __init__(self): ...
    def clone(self) -> typing.Any: ...
    @typing.overload
    @staticmethod
    def getAvailableIDs() -> typing.List[str]: ...
    @typing.overload
    @staticmethod
    def getAvailableIDs(int: int) -> typing.List[str]: ...
    def getDSTSavings(self) -> int: ...
    @staticmethod
    def getDefault() -> 'TimeZone': ...
    @typing.overload
    def getDisplayName(self) -> str: ...
    @typing.overload
    def getDisplayName(self, boolean: bool, int: int) -> str: ...
    @typing.overload
    def getDisplayName(self, locale: Locale) -> str: ...
    @typing.overload
    def getDisplayName(self, boolean: bool, int: int, locale: Locale) -> str: ...
    def getID(self) -> str: ...
    @typing.overload
    def getOffset(self, int: int, int2: int, int3: int, int4: int, int5: int, int6: int) -> int: ...
    @typing.overload
    def getOffset(self, long: int) -> int: ...
    def getRawOffset(self) -> int: ...
    @typing.overload
    @staticmethod
    def getTimeZone(zoneId: java.time.ZoneId) -> 'TimeZone': ...
    @typing.overload
    @staticmethod
    def getTimeZone(string: str) -> 'TimeZone': ...
    def hasSameRules(self, timeZone: 'TimeZone') -> bool: ...
    def inDaylightTime(self, date: Date) -> bool: ...
    def observesDaylightTime(self) -> bool: ...
    @staticmethod
    def setDefault(timeZone: 'TimeZone') -> None: ...
    def setID(self, string: str) -> None: ...
    def setRawOffset(self, int: int) -> None: ...
    def toZoneId(self) -> java.time.ZoneId: ...
    def useDaylightTime(self) -> bool: ...

class Timer:
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, boolean: bool): ...
    @typing.overload
    def __init__(self, string: str): ...
    @typing.overload
    def __init__(self, string: str, boolean: bool): ...
    def cancel(self) -> None: ...
    def purge(self) -> int: ...
    @typing.overload
    def schedule(self, timerTask: 'TimerTask', date: Date) -> None: ...
    @typing.overload
    def schedule(self, timerTask: 'TimerTask', date: Date, long: int) -> None: ...
    @typing.overload
    def schedule(self, timerTask: 'TimerTask', long: int) -> None: ...
    @typing.overload
    def schedule(self, timerTask: 'TimerTask', long: int, long2: int) -> None: ...
    @typing.overload
    def scheduleAtFixedRate(self, timerTask: 'TimerTask', date: Date, long: int) -> None: ...
    @typing.overload
    def scheduleAtFixedRate(self, timerTask: 'TimerTask', long: int, long2: int) -> None: ...

class TimerTask(java.lang.Runnable):
    def cancel(self) -> bool: ...
    def run(self) -> None: ...
    def scheduledExecutionTime(self) -> int: ...

class TooManyListenersException(java.lang.Exception):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: str): ...

class UUID(java.io.Serializable, java.lang.Comparable['UUID']):
    def __init__(self, long: int, long2: int): ...
    def clockSequence(self) -> int: ...
    def compareTo(self, uUID: 'UUID') -> int: ...
    def equals(self, object: typing.Any) -> bool: ...
    @staticmethod
    def fromString(string: str) -> 'UUID': ...
    def getLeastSignificantBits(self) -> int: ...
    def getMostSignificantBits(self) -> int: ...
    def hashCode(self) -> int: ...
    @staticmethod
    def nameUUIDFromBytes(byteArray: typing.List[int]) -> 'UUID': ...
    def node(self) -> int: ...
    @staticmethod
    def randomUUID() -> 'UUID': ...
    def timestamp(self) -> int: ...
    def toString(self) -> str: ...
    def variant(self) -> int: ...
    def version(self) -> int: ...

_AbstractCollection__E = typing.TypeVar('_AbstractCollection__E')  # <E>
class AbstractCollection(Collection[_AbstractCollection__E], typing.Generic[_AbstractCollection__E]):
    def add(self, e: _AbstractCollection__E) -> bool: ...
    def addAll(self, collection: typing.Union[Collection[_AbstractCollection__E], typing.Sequence[_AbstractCollection__E], typing.Set[_AbstractCollection__E]]) -> bool: ...
    def clear(self) -> None: ...
    def contains(self, object: typing.Any) -> bool: ...
    def containsAll(self, collection: typing.Union[Collection[typing.Any], typing.Sequence[typing.Any], typing.Set[typing.Any]]) -> bool: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> Iterator[_AbstractCollection__E]: ...
    def remove(self, object: typing.Any) -> bool: ...
    def removeAll(self, collection: typing.Union[Collection[typing.Any], typing.Sequence[typing.Any], typing.Set[typing.Any]]) -> bool: ...
    def retainAll(self, collection: typing.Union[Collection[typing.Any], typing.Sequence[typing.Any], typing.Set[typing.Any]]) -> bool: ...
    def size(self) -> int: ...
    _toArray_1__T = typing.TypeVar('_toArray_1__T')  # <T>
    @typing.overload
    def toArray(self) -> typing.List[typing.Any]: ...
    @typing.overload
    def toArray(self, tArray: typing.List[_toArray_1__T]) -> typing.List[_toArray_1__T]: ...
    def toString(self) -> str: ...

_AbstractMap__SimpleEntry__K = typing.TypeVar('_AbstractMap__SimpleEntry__K')  # <K>
_AbstractMap__SimpleEntry__V = typing.TypeVar('_AbstractMap__SimpleEntry__V')  # <V>
_AbstractMap__SimpleImmutableEntry__K = typing.TypeVar('_AbstractMap__SimpleImmutableEntry__K')  # <K>
_AbstractMap__SimpleImmutableEntry__V = typing.TypeVar('_AbstractMap__SimpleImmutableEntry__V')  # <V>
_AbstractMap__K = typing.TypeVar('_AbstractMap__K')  # <K>
_AbstractMap__V = typing.TypeVar('_AbstractMap__V')  # <V>
class AbstractMap(Map[_AbstractMap__K, _AbstractMap__V], typing.Generic[_AbstractMap__K, _AbstractMap__V]):
    def clear(self) -> None: ...
    def containsKey(self, object: typing.Any) -> bool: ...
    def containsValue(self, object: typing.Any) -> bool: ...
    def entrySet(self) -> 'Set'[Map.Entry[_AbstractMap__K, _AbstractMap__V]]: ...
    def equals(self, object: typing.Any) -> bool: ...
    def get(self, object: typing.Any) -> _AbstractMap__V: ...
    def hashCode(self) -> int: ...
    def isEmpty(self) -> bool: ...
    def keySet(self) -> 'Set'[_AbstractMap__K]: ...
    def put(self, k: _AbstractMap__K, v: _AbstractMap__V) -> _AbstractMap__V: ...
    def putAll(self, map: typing.Union[Map[_AbstractMap__K, _AbstractMap__V], typing.Mapping[_AbstractMap__K, _AbstractMap__V]]) -> None: ...
    @typing.overload
    def remove(self, object: typing.Any, object2: typing.Any) -> bool: ...
    @typing.overload
    def remove(self, object: typing.Any) -> _AbstractMap__V: ...
    def size(self) -> int: ...
    def toString(self) -> str: ...
    def values(self) -> Collection[_AbstractMap__V]: ...
    class SimpleEntry(Map.Entry[_AbstractMap__SimpleEntry__K, _AbstractMap__SimpleEntry__V], java.io.Serializable, typing.Generic[_AbstractMap__SimpleEntry__K, _AbstractMap__SimpleEntry__V]):
        @typing.overload
        def __init__(self, k: _AbstractMap__SimpleEntry__K, v: _AbstractMap__SimpleEntry__V): ...
        @typing.overload
        def __init__(self, entry: Map.Entry[_AbstractMap__SimpleEntry__K, _AbstractMap__SimpleEntry__V]): ...
        def equals(self, object: typing.Any) -> bool: ...
        def getKey(self) -> _AbstractMap__SimpleEntry__K: ...
        def getValue(self) -> _AbstractMap__SimpleEntry__V: ...
        def hashCode(self) -> int: ...
        def setValue(self, v: _AbstractMap__SimpleEntry__V) -> _AbstractMap__SimpleEntry__V: ...
        def toString(self) -> str: ...
    class SimpleImmutableEntry(Map.Entry[_AbstractMap__SimpleImmutableEntry__K, _AbstractMap__SimpleImmutableEntry__V], java.io.Serializable, typing.Generic[_AbstractMap__SimpleImmutableEntry__K, _AbstractMap__SimpleImmutableEntry__V]):
        @typing.overload
        def __init__(self, k: _AbstractMap__SimpleImmutableEntry__K, v: _AbstractMap__SimpleImmutableEntry__V): ...
        @typing.overload
        def __init__(self, entry: Map.Entry[_AbstractMap__SimpleImmutableEntry__K, _AbstractMap__SimpleImmutableEntry__V]): ...
        def equals(self, object: typing.Any) -> bool: ...
        def getKey(self) -> _AbstractMap__SimpleImmutableEntry__K: ...
        def getValue(self) -> _AbstractMap__SimpleImmutableEntry__V: ...
        def hashCode(self) -> int: ...
        def setValue(self, v: _AbstractMap__SimpleImmutableEntry__V) -> _AbstractMap__SimpleImmutableEntry__V: ...
        def toString(self) -> str: ...

class DuplicateFormatFlagsException(IllegalFormatException):
    def __init__(self, string: str): ...
    def getFlags(self) -> str: ...
    def getMessage(self) -> str: ...

_EventListenerProxy__T = typing.TypeVar('_EventListenerProxy__T', bound=EventListener)  # <T>
class EventListenerProxy(EventListener, typing.Generic[_EventListenerProxy__T]):
    def __init__(self, t: _EventListenerProxy__T): ...
    def getListener(self) -> _EventListenerProxy__T: ...

class FormatFlagsConversionMismatchException(IllegalFormatException):
    def __init__(self, string: str, char: str): ...
    def getConversion(self) -> str: ...
    def getFlags(self) -> str: ...
    def getMessage(self) -> str: ...

class GregorianCalendar(Calendar):
    BC: typing.ClassVar[int] = ...
    AD: typing.ClassVar[int] = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int, int2: int, int3: int): ...
    @typing.overload
    def __init__(self, int: int, int2: int, int3: int, int4: int, int5: int): ...
    @typing.overload
    def __init__(self, int: int, int2: int, int3: int, int4: int, int5: int, int6: int): ...
    @typing.overload
    def __init__(self, locale: Locale): ...
    @typing.overload
    def __init__(self, timeZone: TimeZone): ...
    @typing.overload
    def __init__(self, timeZone: TimeZone, locale: Locale): ...
    def add(self, int: int, int2: int) -> None: ...
    def clone(self) -> typing.Any: ...
    def equals(self, object: typing.Any) -> bool: ...
    def getActualMaximum(self, int: int) -> int: ...
    def getActualMinimum(self, int: int) -> int: ...
    def getCalendarType(self) -> str: ...
    def getGreatestMinimum(self, int: int) -> int: ...
    def getGregorianChange(self) -> Date: ...
    def getLeastMaximum(self, int: int) -> int: ...
    def getMaximum(self, int: int) -> int: ...
    def getMinimum(self, int: int) -> int: ...
    def getTimeZone(self) -> TimeZone: ...
    def getWeekYear(self) -> int: ...
    def getWeeksInWeekYear(self) -> int: ...
    def hashCode(self) -> int: ...
    def isLeapYear(self, int: int) -> bool: ...
    def isWeekDateSupported(self) -> bool: ...
    @typing.overload
    def roll(self, int: int, boolean: bool) -> None: ...
    @typing.overload
    def roll(self, int: int, int2: int) -> None: ...
    def setGregorianChange(self, date: Date) -> None: ...
    def setTimeZone(self, timeZone: TimeZone) -> None: ...
    def setWeekDate(self, int: int, int2: int, int3: int) -> None: ...
    def toZonedDateTime(self) -> java.time.ZonedDateTime: ...

_Hashtable__K = typing.TypeVar('_Hashtable__K')  # <K>
_Hashtable__V = typing.TypeVar('_Hashtable__V')  # <V>
class Hashtable(Dictionary[_Hashtable__K, _Hashtable__V], Map[_Hashtable__K, _Hashtable__V], java.lang.Cloneable, java.io.Serializable, typing.Generic[_Hashtable__K, _Hashtable__V]):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, int: int, float: float): ...
    @typing.overload
    def __init__(self, map: typing.Union[Map[_Hashtable__K, _Hashtable__V], typing.Mapping[_Hashtable__K, _Hashtable__V]]): ...
    def clear(self) -> None: ...
    def clone(self) -> typing.Any: ...
    def compute(self, k: _Hashtable__K, biFunction: typing.Union[java.util.function.BiFunction[_Hashtable__K, _Hashtable__V, _Hashtable__V], typing.Callable[[_Hashtable__K, _Hashtable__V], _Hashtable__V]]) -> _Hashtable__V: ...
    def computeIfAbsent(self, k: _Hashtable__K, function: typing.Union[java.util.function.Function[_Hashtable__K, _Hashtable__V], typing.Callable[[_Hashtable__K], _Hashtable__V]]) -> _Hashtable__V: ...
    def computeIfPresent(self, k: _Hashtable__K, biFunction: typing.Union[java.util.function.BiFunction[_Hashtable__K, _Hashtable__V, _Hashtable__V], typing.Callable[[_Hashtable__K, _Hashtable__V], _Hashtable__V]]) -> _Hashtable__V: ...
    def contains(self, object: typing.Any) -> bool: ...
    def containsKey(self, object: typing.Any) -> bool: ...
    def containsValue(self, object: typing.Any) -> bool: ...
    def elements(self) -> Enumeration[_Hashtable__V]: ...
    def entrySet(self) -> 'Set'[Map.Entry[_Hashtable__K, _Hashtable__V]]: ...
    def equals(self, object: typing.Any) -> bool: ...
    def forEach(self, biConsumer: typing.Union[java.util.function.BiConsumer[_Hashtable__K, _Hashtable__V], typing.Callable[[_Hashtable__K, _Hashtable__V], None]]) -> None: ...
    def get(self, object: typing.Any) -> _Hashtable__V: ...
    def getOrDefault(self, object: typing.Any, v: _Hashtable__V) -> _Hashtable__V: ...
    def hashCode(self) -> int: ...
    def isEmpty(self) -> bool: ...
    def keySet(self) -> 'Set'[_Hashtable__K]: ...
    def keys(self) -> Enumeration[_Hashtable__K]: ...
    def merge(self, k: _Hashtable__K, v: _Hashtable__V, biFunction: typing.Union[java.util.function.BiFunction[_Hashtable__V, _Hashtable__V, _Hashtable__V], typing.Callable[[_Hashtable__V, _Hashtable__V], _Hashtable__V]]) -> _Hashtable__V: ...
    def put(self, k: _Hashtable__K, v: _Hashtable__V) -> _Hashtable__V: ...
    def putAll(self, map: typing.Union[Map[_Hashtable__K, _Hashtable__V], typing.Mapping[_Hashtable__K, _Hashtable__V]]) -> None: ...
    def putIfAbsent(self, k: _Hashtable__K, v: _Hashtable__V) -> _Hashtable__V: ...
    @typing.overload
    def remove(self, object: typing.Any, object2: typing.Any) -> bool: ...
    @typing.overload
    def remove(self, object: typing.Any) -> _Hashtable__V: ...
    @typing.overload
    def replace(self, k: _Hashtable__K, v: _Hashtable__V, v2: _Hashtable__V) -> bool: ...
    @typing.overload
    def replace(self, k: _Hashtable__K, v: _Hashtable__V) -> _Hashtable__V: ...
    def replaceAll(self, biFunction: typing.Union[java.util.function.BiFunction[_Hashtable__K, _Hashtable__V, _Hashtable__V], typing.Callable[[_Hashtable__K, _Hashtable__V], _Hashtable__V]]) -> None: ...
    def size(self) -> int: ...
    def toString(self) -> str: ...
    def values(self) -> Collection[_Hashtable__V]: ...

class IllegalFormatCodePointException(IllegalFormatException):
    def __init__(self, int: int): ...
    def getCodePoint(self) -> int: ...
    def getMessage(self) -> str: ...

class IllegalFormatConversionException(IllegalFormatException):
    def __init__(self, char: str, class_: typing.Type[typing.Any]): ...
    def getArgumentClass(self) -> typing.Type[typing.Any]: ...
    def getConversion(self) -> str: ...
    def getMessage(self) -> str: ...

class IllegalFormatFlagsException(IllegalFormatException):
    def __init__(self, string: str): ...
    def getFlags(self) -> str: ...
    def getMessage(self) -> str: ...

class IllegalFormatPrecisionException(IllegalFormatException):
    def __init__(self, int: int): ...
    def getMessage(self) -> str: ...
    def getPrecision(self) -> int: ...

class IllegalFormatWidthException(IllegalFormatException):
    def __init__(self, int: int): ...
    def getMessage(self) -> str: ...
    def getWidth(self) -> int: ...

class InputMismatchException(NoSuchElementException):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, string: str): ...

_List__E = typing.TypeVar('_List__E')  # <E>
class List(Collection[_List__E], typing.Generic[_List__E], _JList[_List__E]):
    @typing.overload
    def add(self, e: _List__E) -> bool: ...
    @typing.overload
    def add(self, int: int, e: _List__E) -> None: ...
    @typing.overload
    def addAll(self, int: int, collection: typing.Union[Collection[_List__E], typing.Sequence[_List__E], typing.Set[_List__E]]) -> bool: ...
    @typing.overload
    def addAll(self, collection: typing.Union[Collection[_List__E], typing.Sequence[_List__E], typing.Set[_List__E]]) -> bool: ...
    def clear(self) -> None: ...
    def contains(self, object: typing.Any) -> bool: ...
    def containsAll(self, collection: typing.Union[Collection[typing.Any], typing.Sequence[typing.Any], typing.Set[typing.Any]]) -> bool: ...
    def equals(self, object: typing.Any) -> bool: ...
    def get(self, int: int) -> _List__E: ...
    def hashCode(self) -> int: ...
    def indexOf(self, object: typing.Any) -> int: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> Iterator[_List__E]: ...
    def lastIndexOf(self, object: typing.Any) -> int: ...
    @typing.overload
    def listIterator(self) -> 'ListIterator'[_List__E]: ...
    @typing.overload
    def listIterator(self, int: int) -> 'ListIterator'[_List__E]: ...
    def removeAll(self, collection: typing.Union[Collection[typing.Any], typing.Sequence[typing.Any], typing.Set[typing.Any]]) -> bool: ...
    def replaceAll(self, unaryOperator: typing.Union[java.util.function.UnaryOperator[_List__E], typing.Callable]) -> None: ...
    def retainAll(self, collection: typing.Union[Collection[typing.Any], typing.Sequence[typing.Any], typing.Set[typing.Any]]) -> bool: ...
    def set(self, int: int, e: _List__E) -> _List__E: ...
    def size(self) -> int: ...
    def sort(self, comparator: typing.Union[Comparator[_List__E], typing.Callable[[_List__E, _List__E], int]]) -> None: ...
    def spliterator(self) -> 'Spliterator'[_List__E]: ...
    def subList(self, int: int, int2: int) -> 'List'[_List__E]: ...
    _toArray_1__T = typing.TypeVar('_toArray_1__T')  # <T>
    @typing.overload
    def toArray(self) -> typing.List[typing.Any]: ...
    @typing.overload
    def toArray(self, tArray: typing.List[_toArray_1__T]) -> typing.List[_toArray_1__T]: ...

_ListIterator__E = typing.TypeVar('_ListIterator__E')  # <E>
class ListIterator(Iterator[_ListIterator__E], typing.Generic[_ListIterator__E]):
    def add(self, e: _ListIterator__E) -> None: ...
    def hasNext(self) -> bool: ...
    def hasPrevious(self) -> bool: ...
    def next(self) -> _ListIterator__E: ...
    def nextIndex(self) -> int: ...
    def previous(self) -> _ListIterator__E: ...
    def previousIndex(self) -> int: ...
    def remove(self) -> None: ...
    def set(self, e: _ListIterator__E) -> None: ...

class ListResourceBundle(ResourceBundle):
    def __init__(self): ...
    def getKeys(self) -> Enumeration[str]: ...
    def handleGetObject(self, string: str) -> typing.Any: ...

class MissingFormatArgumentException(IllegalFormatException):
    def __init__(self, string: str): ...
    def getFormatSpecifier(self) -> str: ...
    def getMessage(self) -> str: ...

class MissingFormatWidthException(IllegalFormatException):
    def __init__(self, string: str): ...
    def getFormatSpecifier(self) -> str: ...
    def getMessage(self) -> str: ...

class PropertyResourceBundle(ResourceBundle):
    @typing.overload
    def __init__(self, inputStream: java.io.InputStream): ...
    @typing.overload
    def __init__(self, reader: java.io.Reader): ...
    def getKeys(self) -> Enumeration[str]: ...
    def handleGetObject(self, string: str) -> typing.Any: ...

_Queue__E = typing.TypeVar('_Queue__E')  # <E>
class Queue(Collection[_Queue__E], typing.Generic[_Queue__E]):
    def add(self, e: _Queue__E) -> bool: ...
    def element(self) -> _Queue__E: ...
    def equals(self, object: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def offer(self, e: _Queue__E) -> bool: ...
    def peek(self) -> _Queue__E: ...
    def poll(self) -> _Queue__E: ...
    @typing.overload
    def remove(self, object: typing.Any) -> bool: ...
    @typing.overload
    def remove(self) -> _Queue__E: ...

class Scanner(Iterator[str], java.io.Closeable):
    @typing.overload
    def __init__(self, file: typing.Union[java.io.File, jpype.protocol.SupportsPath]): ...
    @typing.overload
    def __init__(self, file: typing.Union[java.io.File, jpype.protocol.SupportsPath], string: str): ...
    @typing.overload
    def __init__(self, inputStream: java.io.InputStream): ...
    @typing.overload
    def __init__(self, inputStream: java.io.InputStream, string: str): ...
    @typing.overload
    def __init__(self, readable: java.lang.Readable): ...
    @typing.overload
    def __init__(self, string: str): ...
    @typing.overload
    def __init__(self, readableByteChannel: java.nio.channels.ReadableByteChannel): ...
    @typing.overload
    def __init__(self, readableByteChannel: java.nio.channels.ReadableByteChannel, string: str): ...
    @typing.overload
    def __init__(self, path: typing.Union[java.nio.file.Path, jpype.protocol.SupportsPath]): ...
    @typing.overload
    def __init__(self, path: typing.Union[java.nio.file.Path, jpype.protocol.SupportsPath], string: str): ...
    def close(self) -> None: ...
    def delimiter(self) -> java.util.regex.Pattern: ...
    @typing.overload
    def findInLine(self, string: str) -> str: ...
    @typing.overload
    def findInLine(self, pattern: java.util.regex.Pattern) -> str: ...
    @typing.overload
    def findWithinHorizon(self, string: str, int: int) -> str: ...
    @typing.overload
    def findWithinHorizon(self, pattern: java.util.regex.Pattern, int: int) -> str: ...
    @typing.overload
    def hasNext(self) -> bool: ...
    @typing.overload
    def hasNext(self, string: str) -> bool: ...
    @typing.overload
    def hasNext(self, pattern: java.util.regex.Pattern) -> bool: ...
    def hasNextBigDecimal(self) -> bool: ...
    @typing.overload
    def hasNextBigInteger(self) -> bool: ...
    @typing.overload
    def hasNextBigInteger(self, int: int) -> bool: ...
    def hasNextBoolean(self) -> bool: ...
    @typing.overload
    def hasNextByte(self) -> bool: ...
    @typing.overload
    def hasNextByte(self, int: int) -> bool: ...
    def hasNextDouble(self) -> bool: ...
    def hasNextFloat(self) -> bool: ...
    @typing.overload
    def hasNextInt(self) -> bool: ...
    @typing.overload
    def hasNextInt(self, int: int) -> bool: ...
    def hasNextLine(self) -> bool: ...
    @typing.overload
    def hasNextLong(self) -> bool: ...
    @typing.overload
    def hasNextLong(self, int: int) -> bool: ...
    @typing.overload
    def hasNextShort(self) -> bool: ...
    @typing.overload
    def hasNextShort(self, int: int) -> bool: ...
    def ioException(self) -> java.io.IOException: ...
    def locale(self) -> Locale: ...
    def match(self) -> java.util.regex.MatchResult: ...
    @typing.overload
    def next(self) -> str: ...
    @typing.overload
    def next(self, string: str) -> str: ...
    @typing.overload
    def next(self, pattern: java.util.regex.Pattern) -> str: ...
    def nextBigDecimal(self) -> java.math.BigDecimal: ...
    @typing.overload
    def nextBigInteger(self) -> java.math.BigInteger: ...
    @typing.overload
    def nextBigInteger(self, int: int) -> java.math.BigInteger: ...
    def nextBoolean(self) -> bool: ...
    @typing.overload
    def nextByte(self) -> int: ...
    @typing.overload
    def nextByte(self, int: int) -> int: ...
    def nextDouble(self) -> float: ...
    def nextFloat(self) -> float: ...
    @typing.overload
    def nextInt(self) -> int: ...
    @typing.overload
    def nextInt(self, int: int) -> int: ...
    def nextLine(self) -> str: ...
    @typing.overload
    def nextLong(self) -> int: ...
    @typing.overload
    def nextLong(self, int: int) -> int: ...
    @typing.overload
    def nextShort(self) -> int: ...
    @typing.overload
    def nextShort(self, int: int) -> int: ...
    def radix(self) -> int: ...
    def remove(self) -> None: ...
    def reset(self) -> 'Scanner': ...
    @typing.overload
    def skip(self, string: str) -> 'Scanner': ...
    @typing.overload
    def skip(self, pattern: java.util.regex.Pattern) -> 'Scanner': ...
    def toString(self) -> str: ...
    @typing.overload
    def useDelimiter(self, string: str) -> 'Scanner': ...
    @typing.overload
    def useDelimiter(self, pattern: java.util.regex.Pattern) -> 'Scanner': ...
    def useLocale(self, locale: Locale) -> 'Scanner': ...
    def useRadix(self, int: int) -> 'Scanner': ...

_Set__E = typing.TypeVar('_Set__E')  # <E>
class Set(Collection[_Set__E], typing.Generic[_Set__E], _JSet[_Set__E]):
    def add(self, e: _Set__E) -> bool: ...
    def addAll(self, collection: typing.Union[Collection[_Set__E], typing.Sequence[_Set__E], typing.Set[_Set__E]]) -> bool: ...
    def clear(self) -> None: ...
    def contains(self, object: typing.Any) -> bool: ...
    def containsAll(self, collection: typing.Union[Collection[typing.Any], typing.Sequence[typing.Any], typing.Set[typing.Any]]) -> bool: ...
    def equals(self, object: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> Iterator[_Set__E]: ...
    def remove(self, object: typing.Any) -> bool: ...
    def removeAll(self, collection: typing.Union[Collection[typing.Any], typing.Sequence[typing.Any], typing.Set[typing.Any]]) -> bool: ...
    def retainAll(self, collection: typing.Union[Collection[typing.Any], typing.Sequence[typing.Any], typing.Set[typing.Any]]) -> bool: ...
    def size(self) -> int: ...
    def spliterator(self) -> 'Spliterator'[_Set__E]: ...
    _toArray_1__T = typing.TypeVar('_toArray_1__T')  # <T>
    @typing.overload
    def toArray(self) -> typing.List[typing.Any]: ...
    @typing.overload
    def toArray(self, tArray: typing.List[_toArray_1__T]) -> typing.List[_toArray_1__T]: ...

class SimpleTimeZone(TimeZone):
    WALL_TIME: typing.ClassVar[int] = ...
    STANDARD_TIME: typing.ClassVar[int] = ...
    UTC_TIME: typing.ClassVar[int] = ...
    @typing.overload
    def __init__(self, int: int, string: str): ...
    @typing.overload
    def __init__(self, int: int, string: str, int2: int, int3: int, int4: int, int5: int, int6: int, int7: int, int8: int, int9: int): ...
    @typing.overload
    def __init__(self, int: int, string: str, int2: int, int3: int, int4: int, int5: int, int6: int, int7: int, int8: int, int9: int, int10: int): ...
    @typing.overload
    def __init__(self, int: int, string: str, int2: int, int3: int, int4: int, int5: int, int6: int, int7: int, int8: int, int9: int, int10: int, int11: int, int12: int): ...
    def clone(self) -> typing.Any: ...
    def equals(self, object: typing.Any) -> bool: ...
    def getDSTSavings(self) -> int: ...
    @typing.overload
    def getOffset(self, int: int, int2: int, int3: int, int4: int, int5: int, int6: int) -> int: ...
    @typing.overload
    def getOffset(self, long: int) -> int: ...
    def getRawOffset(self) -> int: ...
    def hasSameRules(self, timeZone: TimeZone) -> bool: ...
    def hashCode(self) -> int: ...
    def inDaylightTime(self, date: Date) -> bool: ...
    def observesDaylightTime(self) -> bool: ...
    def setDSTSavings(self, int: int) -> None: ...
    @typing.overload
    def setEndRule(self, int: int, int2: int, int3: int) -> None: ...
    @typing.overload
    def setEndRule(self, int: int, int2: int, int3: int, int4: int) -> None: ...
    @typing.overload
    def setEndRule(self, int: int, int2: int, int3: int, int4: int, boolean: bool) -> None: ...
    def setRawOffset(self, int: int) -> None: ...
    @typing.overload
    def setStartRule(self, int: int, int2: int, int3: int) -> None: ...
    @typing.overload
    def setStartRule(self, int: int, int2: int, int3: int, int4: int) -> None: ...
    @typing.overload
    def setStartRule(self, int: int, int2: int, int3: int, int4: int, boolean: bool) -> None: ...
    def setStartYear(self, int: int) -> None: ...
    def toString(self) -> str: ...
    def useDaylightTime(self) -> bool: ...

_SortedMap__K = typing.TypeVar('_SortedMap__K')  # <K>
_SortedMap__V = typing.TypeVar('_SortedMap__V')  # <V>
class SortedMap(Map[_SortedMap__K, _SortedMap__V], typing.Generic[_SortedMap__K, _SortedMap__V]):
    def comparator(self) -> Comparator[_SortedMap__K]: ...
    def entrySet(self) -> Set[Map.Entry[_SortedMap__K, _SortedMap__V]]: ...
    def equals(self, object: typing.Any) -> bool: ...
    def firstKey(self) -> _SortedMap__K: ...
    def hashCode(self) -> int: ...
    def headMap(self, k: _SortedMap__K) -> 'SortedMap'[_SortedMap__K, _SortedMap__V]: ...
    def keySet(self) -> Set[_SortedMap__K]: ...
    def lastKey(self) -> _SortedMap__K: ...
    def subMap(self, k: _SortedMap__K, k2: _SortedMap__K) -> 'SortedMap'[_SortedMap__K, _SortedMap__V]: ...
    def tailMap(self, k: _SortedMap__K) -> 'SortedMap'[_SortedMap__K, _SortedMap__V]: ...
    def values(self) -> Collection[_SortedMap__V]: ...

class StringTokenizer(Enumeration[typing.Any]):
    @typing.overload
    def __init__(self, string: str): ...
    @typing.overload
    def __init__(self, string: str, string2: str): ...
    @typing.overload
    def __init__(self, string: str, string2: str, boolean: bool): ...
    def countTokens(self) -> int: ...
    def hasMoreElements(self) -> bool: ...
    def hasMoreTokens(self) -> bool: ...
    def nextElement(self) -> typing.Any: ...
    @typing.overload
    def nextToken(self) -> str: ...
    @typing.overload
    def nextToken(self, string: str) -> str: ...

class UnknownFormatConversionException(IllegalFormatException):
    def __init__(self, string: str): ...
    def getConversion(self) -> str: ...
    def getMessage(self) -> str: ...

class UnknownFormatFlagsException(IllegalFormatException):
    def __init__(self, string: str): ...
    def getFlags(self) -> str: ...
    def getMessage(self) -> str: ...

_AbstractList__E = typing.TypeVar('_AbstractList__E')  # <E>
class AbstractList(AbstractCollection[_AbstractList__E], List[_AbstractList__E], typing.Generic[_AbstractList__E]):
    @typing.overload
    def add(self, e: _AbstractList__E) -> bool: ...
    @typing.overload
    def add(self, int: int, e: _AbstractList__E) -> None: ...
    @typing.overload
    def addAll(self, collection: typing.Union[Collection[_AbstractList__E], typing.Sequence[_AbstractList__E], typing.Set[_AbstractList__E]]) -> bool: ...
    @typing.overload
    def addAll(self, int: int, collection: typing.Union[Collection[_AbstractList__E], typing.Sequence[_AbstractList__E], typing.Set[_AbstractList__E]]) -> bool: ...
    def clear(self) -> None: ...
    def equals(self, object: typing.Any) -> bool: ...
    def get(self, int: int) -> _AbstractList__E: ...
    def hashCode(self) -> int: ...
    def indexOf(self, object: typing.Any) -> int: ...
    def iterator(self) -> Iterator[_AbstractList__E]: ...
    def lastIndexOf(self, object: typing.Any) -> int: ...
    @typing.overload
    def listIterator(self) -> ListIterator[_AbstractList__E]: ...
    @typing.overload
    def listIterator(self, int: int) -> ListIterator[_AbstractList__E]: ...
    def set(self, int: int, e: _AbstractList__E) -> _AbstractList__E: ...
    def subList(self, int: int, int2: int) -> List[_AbstractList__E]: ...

_AbstractQueue__E = typing.TypeVar('_AbstractQueue__E')  # <E>
class AbstractQueue(AbstractCollection[_AbstractQueue__E], Queue[_AbstractQueue__E], typing.Generic[_AbstractQueue__E]):
    def add(self, e: _AbstractQueue__E) -> bool: ...
    def addAll(self, collection: typing.Union[Collection[_AbstractQueue__E], typing.Sequence[_AbstractQueue__E], typing.Set[_AbstractQueue__E]]) -> bool: ...
    def clear(self) -> None: ...
    def element(self) -> _AbstractQueue__E: ...
    @typing.overload
    def remove(self, object: typing.Any) -> bool: ...
    @typing.overload
    def remove(self) -> _AbstractQueue__E: ...

_AbstractSet__E = typing.TypeVar('_AbstractSet__E')  # <E>
class AbstractSet(AbstractCollection[_AbstractSet__E], Set[_AbstractSet__E], typing.Generic[_AbstractSet__E]):
    def equals(self, object: typing.Any) -> bool: ...
    def hashCode(self) -> int: ...
    def removeAll(self, collection: typing.Union[Collection[typing.Any], typing.Sequence[typing.Any], typing.Set[typing.Any]]) -> bool: ...

_Deque__E = typing.TypeVar('_Deque__E')  # <E>
class Deque(Queue[_Deque__E], typing.Generic[_Deque__E]):
    def add(self, e: _Deque__E) -> bool: ...
    def addFirst(self, e: _Deque__E) -> None: ...
    def addLast(self, e: _Deque__E) -> None: ...
    def contains(self, object: typing.Any) -> bool: ...
    def descendingIterator(self) -> Iterator[_Deque__E]: ...
    def element(self) -> _Deque__E: ...
    def equals(self, object: typing.Any) -> bool: ...
    def getFirst(self) -> _Deque__E: ...
    def getLast(self) -> _Deque__E: ...
    def hashCode(self) -> int: ...
    def iterator(self) -> Iterator[_Deque__E]: ...
    def offer(self, e: _Deque__E) -> bool: ...
    def offerFirst(self, e: _Deque__E) -> bool: ...
    def offerLast(self, e: _Deque__E) -> bool: ...
    def peek(self) -> _Deque__E: ...
    def peekFirst(self) -> _Deque__E: ...
    def peekLast(self) -> _Deque__E: ...
    def poll(self) -> _Deque__E: ...
    def pollFirst(self) -> _Deque__E: ...
    def pollLast(self) -> _Deque__E: ...
    def pop(self) -> _Deque__E: ...
    def push(self, e: _Deque__E) -> None: ...
    @typing.overload
    def remove(self, object: typing.Any) -> bool: ...
    @typing.overload
    def remove(self) -> _Deque__E: ...
    def removeFirst(self) -> _Deque__E: ...
    def removeFirstOccurrence(self, object: typing.Any) -> bool: ...
    def removeLast(self) -> _Deque__E: ...
    def removeLastOccurrence(self, object: typing.Any) -> bool: ...
    def size(self) -> int: ...

_EnumMap__K = typing.TypeVar('_EnumMap__K', bound=java.lang.Enum)  # <K>
_EnumMap__V = typing.TypeVar('_EnumMap__V')  # <V>
class EnumMap(AbstractMap[_EnumMap__K, _EnumMap__V], java.io.Serializable, java.lang.Cloneable, typing.Generic[_EnumMap__K, _EnumMap__V]):
    @typing.overload
    def __init__(self, class_: typing.Type[_EnumMap__K]): ...
    @typing.overload
    def __init__(self, enumMap: 'EnumMap'[_EnumMap__K, _EnumMap__V]): ...
    @typing.overload
    def __init__(self, map: typing.Union[Map[_EnumMap__K, _EnumMap__V], typing.Mapping[_EnumMap__K, _EnumMap__V]]): ...
    def clear(self) -> None: ...
    def clone(self) -> 'EnumMap'[_EnumMap__K, _EnumMap__V]: ...
    def containsKey(self, object: typing.Any) -> bool: ...
    def containsValue(self, object: typing.Any) -> bool: ...
    def entrySet(self) -> Set[Map.Entry[_EnumMap__K, _EnumMap__V]]: ...
    def equals(self, object: typing.Any) -> bool: ...
    def get(self, object: typing.Any) -> _EnumMap__V: ...
    def hashCode(self) -> int: ...
    def keySet(self) -> Set[_EnumMap__K]: ...
    def put(self, k: _EnumMap__K, v: _EnumMap__V) -> _EnumMap__V: ...
    def putAll(self, map: typing.Union[Map[_EnumMap__K, _EnumMap__V], typing.Mapping[_EnumMap__K, _EnumMap__V]]) -> None: ...
    @typing.overload
    def remove(self, object: typing.Any, object2: typing.Any) -> bool: ...
    @typing.overload
    def remove(self, object: typing.Any) -> _EnumMap__V: ...
    def size(self) -> int: ...
    def values(self) -> Collection[_EnumMap__V]: ...

_HashMap__K = typing.TypeVar('_HashMap__K')  # <K>
_HashMap__V = typing.TypeVar('_HashMap__V')  # <V>
class HashMap(AbstractMap[_HashMap__K, _HashMap__V], Map[_HashMap__K, _HashMap__V], java.lang.Cloneable, java.io.Serializable, typing.Generic[_HashMap__K, _HashMap__V]):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, int: int, float: float): ...
    @typing.overload
    def __init__(self, map: typing.Union[Map[_HashMap__K, _HashMap__V], typing.Mapping[_HashMap__K, _HashMap__V]]): ...
    def clear(self) -> None: ...
    def clone(self) -> typing.Any: ...
    def compute(self, k: _HashMap__K, biFunction: typing.Union[java.util.function.BiFunction[_HashMap__K, _HashMap__V, _HashMap__V], typing.Callable[[_HashMap__K, _HashMap__V], _HashMap__V]]) -> _HashMap__V: ...
    def computeIfAbsent(self, k: _HashMap__K, function: typing.Union[java.util.function.Function[_HashMap__K, _HashMap__V], typing.Callable[[_HashMap__K], _HashMap__V]]) -> _HashMap__V: ...
    def computeIfPresent(self, k: _HashMap__K, biFunction: typing.Union[java.util.function.BiFunction[_HashMap__K, _HashMap__V, _HashMap__V], typing.Callable[[_HashMap__K, _HashMap__V], _HashMap__V]]) -> _HashMap__V: ...
    def containsKey(self, object: typing.Any) -> bool: ...
    def containsValue(self, object: typing.Any) -> bool: ...
    def entrySet(self) -> Set[Map.Entry[_HashMap__K, _HashMap__V]]: ...
    def forEach(self, biConsumer: typing.Union[java.util.function.BiConsumer[_HashMap__K, _HashMap__V], typing.Callable[[_HashMap__K, _HashMap__V], None]]) -> None: ...
    def get(self, object: typing.Any) -> _HashMap__V: ...
    def getOrDefault(self, object: typing.Any, v: _HashMap__V) -> _HashMap__V: ...
    def isEmpty(self) -> bool: ...
    def keySet(self) -> Set[_HashMap__K]: ...
    def merge(self, k: _HashMap__K, v: _HashMap__V, biFunction: typing.Union[java.util.function.BiFunction[_HashMap__V, _HashMap__V, _HashMap__V], typing.Callable[[_HashMap__V, _HashMap__V], _HashMap__V]]) -> _HashMap__V: ...
    def put(self, k: _HashMap__K, v: _HashMap__V) -> _HashMap__V: ...
    def putAll(self, map: typing.Union[Map[_HashMap__K, _HashMap__V], typing.Mapping[_HashMap__K, _HashMap__V]]) -> None: ...
    def putIfAbsent(self, k: _HashMap__K, v: _HashMap__V) -> _HashMap__V: ...
    @typing.overload
    def remove(self, object: typing.Any, object2: typing.Any) -> bool: ...
    @typing.overload
    def remove(self, object: typing.Any) -> _HashMap__V: ...
    @typing.overload
    def replace(self, k: _HashMap__K, v: _HashMap__V, v2: _HashMap__V) -> bool: ...
    @typing.overload
    def replace(self, k: _HashMap__K, v: _HashMap__V) -> _HashMap__V: ...
    def replaceAll(self, biFunction: typing.Union[java.util.function.BiFunction[_HashMap__K, _HashMap__V, _HashMap__V], typing.Callable[[_HashMap__K, _HashMap__V], _HashMap__V]]) -> None: ...
    def size(self) -> int: ...
    def values(self) -> Collection[_HashMap__V]: ...

_IdentityHashMap__K = typing.TypeVar('_IdentityHashMap__K')  # <K>
_IdentityHashMap__V = typing.TypeVar('_IdentityHashMap__V')  # <V>
class IdentityHashMap(AbstractMap[_IdentityHashMap__K, _IdentityHashMap__V], Map[_IdentityHashMap__K, _IdentityHashMap__V], java.io.Serializable, java.lang.Cloneable, typing.Generic[_IdentityHashMap__K, _IdentityHashMap__V]):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, map: typing.Union[Map[_IdentityHashMap__K, _IdentityHashMap__V], typing.Mapping[_IdentityHashMap__K, _IdentityHashMap__V]]): ...
    def clear(self) -> None: ...
    def clone(self) -> typing.Any: ...
    def containsKey(self, object: typing.Any) -> bool: ...
    def containsValue(self, object: typing.Any) -> bool: ...
    def entrySet(self) -> Set[Map.Entry[_IdentityHashMap__K, _IdentityHashMap__V]]: ...
    def equals(self, object: typing.Any) -> bool: ...
    def forEach(self, biConsumer: typing.Union[java.util.function.BiConsumer[_IdentityHashMap__K, _IdentityHashMap__V], typing.Callable[[_IdentityHashMap__K, _IdentityHashMap__V], None]]) -> None: ...
    def get(self, object: typing.Any) -> _IdentityHashMap__V: ...
    def hashCode(self) -> int: ...
    def isEmpty(self) -> bool: ...
    def keySet(self) -> Set[_IdentityHashMap__K]: ...
    def put(self, k: _IdentityHashMap__K, v: _IdentityHashMap__V) -> _IdentityHashMap__V: ...
    def putAll(self, map: typing.Union[Map[_IdentityHashMap__K, _IdentityHashMap__V], typing.Mapping[_IdentityHashMap__K, _IdentityHashMap__V]]) -> None: ...
    @typing.overload
    def remove(self, object: typing.Any, object2: typing.Any) -> bool: ...
    @typing.overload
    def remove(self, object: typing.Any) -> _IdentityHashMap__V: ...
    def replaceAll(self, biFunction: typing.Union[java.util.function.BiFunction[_IdentityHashMap__K, _IdentityHashMap__V, _IdentityHashMap__V], typing.Callable[[_IdentityHashMap__K, _IdentityHashMap__V], _IdentityHashMap__V]]) -> None: ...
    def size(self) -> int: ...
    def values(self) -> Collection[_IdentityHashMap__V]: ...

_NavigableMap__K = typing.TypeVar('_NavigableMap__K')  # <K>
_NavigableMap__V = typing.TypeVar('_NavigableMap__V')  # <V>
class NavigableMap(SortedMap[_NavigableMap__K, _NavigableMap__V], typing.Generic[_NavigableMap__K, _NavigableMap__V]):
    def ceilingEntry(self, k: _NavigableMap__K) -> Map.Entry[_NavigableMap__K, _NavigableMap__V]: ...
    def ceilingKey(self, k: _NavigableMap__K) -> _NavigableMap__K: ...
    def descendingKeySet(self) -> 'NavigableSet'[_NavigableMap__K]: ...
    def descendingMap(self) -> 'NavigableMap'[_NavigableMap__K, _NavigableMap__V]: ...
    def equals(self, object: typing.Any) -> bool: ...
    def firstEntry(self) -> Map.Entry[_NavigableMap__K, _NavigableMap__V]: ...
    def floorEntry(self, k: _NavigableMap__K) -> Map.Entry[_NavigableMap__K, _NavigableMap__V]: ...
    def floorKey(self, k: _NavigableMap__K) -> _NavigableMap__K: ...
    def hashCode(self) -> int: ...
    @typing.overload
    def headMap(self, k: _NavigableMap__K, boolean: bool) -> 'NavigableMap'[_NavigableMap__K, _NavigableMap__V]: ...
    @typing.overload
    def headMap(self, k: _NavigableMap__K) -> SortedMap[_NavigableMap__K, _NavigableMap__V]: ...
    def higherEntry(self, k: _NavigableMap__K) -> Map.Entry[_NavigableMap__K, _NavigableMap__V]: ...
    def higherKey(self, k: _NavigableMap__K) -> _NavigableMap__K: ...
    def lastEntry(self) -> Map.Entry[_NavigableMap__K, _NavigableMap__V]: ...
    def lowerEntry(self, k: _NavigableMap__K) -> Map.Entry[_NavigableMap__K, _NavigableMap__V]: ...
    def lowerKey(self, k: _NavigableMap__K) -> _NavigableMap__K: ...
    def navigableKeySet(self) -> 'NavigableSet'[_NavigableMap__K]: ...
    def pollFirstEntry(self) -> Map.Entry[_NavigableMap__K, _NavigableMap__V]: ...
    def pollLastEntry(self) -> Map.Entry[_NavigableMap__K, _NavigableMap__V]: ...
    @typing.overload
    def subMap(self, k: _NavigableMap__K, boolean: bool, k2: _NavigableMap__K, boolean2: bool) -> 'NavigableMap'[_NavigableMap__K, _NavigableMap__V]: ...
    @typing.overload
    def subMap(self, k: _NavigableMap__K, k2: _NavigableMap__K) -> SortedMap[_NavigableMap__K, _NavigableMap__V]: ...
    @typing.overload
    def tailMap(self, k: _NavigableMap__K, boolean: bool) -> 'NavigableMap'[_NavigableMap__K, _NavigableMap__V]: ...
    @typing.overload
    def tailMap(self, k: _NavigableMap__K) -> SortedMap[_NavigableMap__K, _NavigableMap__V]: ...

class Properties(Hashtable[typing.Any, typing.Any]):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, properties: 'Properties'): ...
    @typing.overload
    def getProperty(self, string: str) -> str: ...
    @typing.overload
    def getProperty(self, string: str, string2: str) -> str: ...
    @typing.overload
    def list(self, printStream: java.io.PrintStream) -> None: ...
    @typing.overload
    def list(self, printWriter: java.io.PrintWriter) -> None: ...
    @typing.overload
    def load(self, inputStream: java.io.InputStream) -> None: ...
    @typing.overload
    def load(self, reader: java.io.Reader) -> None: ...
    def loadFromXML(self, inputStream: java.io.InputStream) -> None: ...
    def propertyNames(self) -> Enumeration[typing.Any]: ...
    def save(self, outputStream: java.io.OutputStream, string: str) -> None: ...
    def setProperty(self, string: str, string2: str) -> typing.Any: ...
    @typing.overload
    def store(self, outputStream: java.io.OutputStream, string: str) -> None: ...
    @typing.overload
    def store(self, writer: java.io.Writer, string: str) -> None: ...
    @typing.overload
    def storeToXML(self, outputStream: java.io.OutputStream, string: str) -> None: ...
    @typing.overload
    def storeToXML(self, outputStream: java.io.OutputStream, string: str, string2: str) -> None: ...
    def stringPropertyNames(self) -> Set[str]: ...

_SortedSet__E = typing.TypeVar('_SortedSet__E')  # <E>
class SortedSet(Set[_SortedSet__E], typing.Generic[_SortedSet__E]):
    def comparator(self) -> Comparator[_SortedSet__E]: ...
    def equals(self, object: typing.Any) -> bool: ...
    def first(self) -> _SortedSet__E: ...
    def hashCode(self) -> int: ...
    def headSet(self, e: _SortedSet__E) -> 'SortedSet'[_SortedSet__E]: ...
    def last(self) -> _SortedSet__E: ...
    def spliterator(self) -> 'Spliterator'[_SortedSet__E]: ...
    def subSet(self, e: _SortedSet__E, e2: _SortedSet__E) -> 'SortedSet'[_SortedSet__E]: ...
    def tailSet(self, e: _SortedSet__E) -> 'SortedSet'[_SortedSet__E]: ...

_WeakHashMap__K = typing.TypeVar('_WeakHashMap__K')  # <K>
_WeakHashMap__V = typing.TypeVar('_WeakHashMap__V')  # <V>
class WeakHashMap(AbstractMap[_WeakHashMap__K, _WeakHashMap__V], Map[_WeakHashMap__K, _WeakHashMap__V], typing.Generic[_WeakHashMap__K, _WeakHashMap__V]):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, int: int, float: float): ...
    @typing.overload
    def __init__(self, map: typing.Union[Map[_WeakHashMap__K, _WeakHashMap__V], typing.Mapping[_WeakHashMap__K, _WeakHashMap__V]]): ...
    def clear(self) -> None: ...
    def containsKey(self, object: typing.Any) -> bool: ...
    def containsValue(self, object: typing.Any) -> bool: ...
    def entrySet(self) -> Set[Map.Entry[_WeakHashMap__K, _WeakHashMap__V]]: ...
    def forEach(self, biConsumer: typing.Union[java.util.function.BiConsumer[_WeakHashMap__K, _WeakHashMap__V], typing.Callable[[_WeakHashMap__K, _WeakHashMap__V], None]]) -> None: ...
    def get(self, object: typing.Any) -> _WeakHashMap__V: ...
    def isEmpty(self) -> bool: ...
    def keySet(self) -> Set[_WeakHashMap__K]: ...
    def put(self, k: _WeakHashMap__K, v: _WeakHashMap__V) -> _WeakHashMap__V: ...
    def putAll(self, map: typing.Union[Map[_WeakHashMap__K, _WeakHashMap__V], typing.Mapping[_WeakHashMap__K, _WeakHashMap__V]]) -> None: ...
    @typing.overload
    def remove(self, object: typing.Any, object2: typing.Any) -> bool: ...
    @typing.overload
    def remove(self, object: typing.Any) -> _WeakHashMap__V: ...
    def replaceAll(self, biFunction: typing.Union[java.util.function.BiFunction[_WeakHashMap__K, _WeakHashMap__V, _WeakHashMap__V], typing.Callable[[_WeakHashMap__K, _WeakHashMap__V], _WeakHashMap__V]]) -> None: ...
    def size(self) -> int: ...
    def values(self) -> Collection[_WeakHashMap__V]: ...

_AbstractSequentialList__E = typing.TypeVar('_AbstractSequentialList__E')  # <E>
class AbstractSequentialList(AbstractList[_AbstractSequentialList__E], typing.Generic[_AbstractSequentialList__E]):
    @typing.overload
    def add(self, e: _AbstractSequentialList__E) -> bool: ...
    @typing.overload
    def add(self, int: int, e: _AbstractSequentialList__E) -> None: ...
    @typing.overload
    def addAll(self, collection: typing.Union[Collection[_AbstractSequentialList__E], typing.Sequence[_AbstractSequentialList__E], typing.Set[_AbstractSequentialList__E]]) -> bool: ...
    @typing.overload
    def addAll(self, int: int, collection: typing.Union[Collection[_AbstractSequentialList__E], typing.Sequence[_AbstractSequentialList__E], typing.Set[_AbstractSequentialList__E]]) -> bool: ...
    def get(self, int: int) -> _AbstractSequentialList__E: ...
    def iterator(self) -> Iterator[_AbstractSequentialList__E]: ...
    @typing.overload
    def listIterator(self, int: int) -> ListIterator[_AbstractSequentialList__E]: ...
    @typing.overload
    def listIterator(self) -> ListIterator[_AbstractSequentialList__E]: ...
    def set(self, int: int, e: _AbstractSequentialList__E) -> _AbstractSequentialList__E: ...

_ArrayDeque__E = typing.TypeVar('_ArrayDeque__E')  # <E>
class ArrayDeque(AbstractCollection[_ArrayDeque__E], Deque[_ArrayDeque__E], java.lang.Cloneable, java.io.Serializable, typing.Generic[_ArrayDeque__E]):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, collection: typing.Union[Collection[_ArrayDeque__E], typing.Sequence[_ArrayDeque__E], typing.Set[_ArrayDeque__E]]): ...
    def add(self, e: _ArrayDeque__E) -> bool: ...
    def addFirst(self, e: _ArrayDeque__E) -> None: ...
    def addLast(self, e: _ArrayDeque__E) -> None: ...
    def clear(self) -> None: ...
    def clone(self) -> 'ArrayDeque'[_ArrayDeque__E]: ...
    def contains(self, object: typing.Any) -> bool: ...
    def descendingIterator(self) -> Iterator[_ArrayDeque__E]: ...
    def element(self) -> _ArrayDeque__E: ...
    def getFirst(self) -> _ArrayDeque__E: ...
    def getLast(self) -> _ArrayDeque__E: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> Iterator[_ArrayDeque__E]: ...
    def offer(self, e: _ArrayDeque__E) -> bool: ...
    def offerFirst(self, e: _ArrayDeque__E) -> bool: ...
    def offerLast(self, e: _ArrayDeque__E) -> bool: ...
    def peek(self) -> _ArrayDeque__E: ...
    def peekFirst(self) -> _ArrayDeque__E: ...
    def peekLast(self) -> _ArrayDeque__E: ...
    def poll(self) -> _ArrayDeque__E: ...
    def pollFirst(self) -> _ArrayDeque__E: ...
    def pollLast(self) -> _ArrayDeque__E: ...
    def pop(self) -> _ArrayDeque__E: ...
    def push(self, e: _ArrayDeque__E) -> None: ...
    @typing.overload
    def remove(self, object: typing.Any) -> bool: ...
    @typing.overload
    def remove(self) -> _ArrayDeque__E: ...
    def removeFirst(self) -> _ArrayDeque__E: ...
    def removeFirstOccurrence(self, object: typing.Any) -> bool: ...
    def removeLast(self) -> _ArrayDeque__E: ...
    def removeLastOccurrence(self, object: typing.Any) -> bool: ...
    def size(self) -> int: ...
    def spliterator(self) -> 'Spliterator'[_ArrayDeque__E]: ...
    _toArray_1__T = typing.TypeVar('_toArray_1__T')  # <T>
    @typing.overload
    def toArray(self) -> typing.List[typing.Any]: ...
    @typing.overload
    def toArray(self, tArray: typing.List[_toArray_1__T]) -> typing.List[_toArray_1__T]: ...

_ArrayList__E = typing.TypeVar('_ArrayList__E')  # <E>
class ArrayList(AbstractList[_ArrayList__E], List[_ArrayList__E], RandomAccess, java.lang.Cloneable, java.io.Serializable, typing.Generic[_ArrayList__E]):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, collection: typing.Union[Collection[_ArrayList__E], typing.Sequence[_ArrayList__E], typing.Set[_ArrayList__E]]): ...
    @typing.overload
    def add(self, e: _ArrayList__E) -> bool: ...
    @typing.overload
    def add(self, int: int, e: _ArrayList__E) -> None: ...
    @typing.overload
    def addAll(self, int: int, collection: typing.Union[Collection[_ArrayList__E], typing.Sequence[_ArrayList__E], typing.Set[_ArrayList__E]]) -> bool: ...
    @typing.overload
    def addAll(self, collection: typing.Union[Collection[_ArrayList__E], typing.Sequence[_ArrayList__E], typing.Set[_ArrayList__E]]) -> bool: ...
    def clear(self) -> None: ...
    def clone(self) -> typing.Any: ...
    def contains(self, object: typing.Any) -> bool: ...
    def ensureCapacity(self, int: int) -> None: ...
    def forEach(self, consumer: typing.Union[java.util.function.Consumer[_ArrayList__E], typing.Callable[[_ArrayList__E], None]]) -> None: ...
    def get(self, int: int) -> _ArrayList__E: ...
    def indexOf(self, object: typing.Any) -> int: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> Iterator[_ArrayList__E]: ...
    def lastIndexOf(self, object: typing.Any) -> int: ...
    @typing.overload
    def listIterator(self) -> ListIterator[_ArrayList__E]: ...
    @typing.overload
    def listIterator(self, int: int) -> ListIterator[_ArrayList__E]: ...
    def removeAll(self, collection: typing.Union[Collection[typing.Any], typing.Sequence[typing.Any], typing.Set[typing.Any]]) -> bool: ...
    def removeIf(self, predicate: typing.Union[java.util.function.Predicate[_ArrayList__E], typing.Callable[[_ArrayList__E], bool]]) -> bool: ...
    def replaceAll(self, unaryOperator: typing.Union[java.util.function.UnaryOperator[_ArrayList__E], typing.Callable]) -> None: ...
    def retainAll(self, collection: typing.Union[Collection[typing.Any], typing.Sequence[typing.Any], typing.Set[typing.Any]]) -> bool: ...
    def set(self, int: int, e: _ArrayList__E) -> _ArrayList__E: ...
    def size(self) -> int: ...
    def sort(self, comparator: typing.Union[Comparator[_ArrayList__E], typing.Callable[[_ArrayList__E, _ArrayList__E], int]]) -> None: ...
    def spliterator(self) -> 'Spliterator'[_ArrayList__E]: ...
    def subList(self, int: int, int2: int) -> List[_ArrayList__E]: ...
    _toArray_1__T = typing.TypeVar('_toArray_1__T')  # <T>
    @typing.overload
    def toArray(self) -> typing.List[typing.Any]: ...
    @typing.overload
    def toArray(self, tArray: typing.List[_toArray_1__T]) -> typing.List[_toArray_1__T]: ...
    def trimToSize(self) -> None: ...

_EnumSet__E = typing.TypeVar('_EnumSet__E', bound=java.lang.Enum)  # <E>
class EnumSet(AbstractSet[_EnumSet__E], java.lang.Cloneable, java.io.Serializable, typing.Generic[_EnumSet__E]):
    _allOf__E = typing.TypeVar('_allOf__E', bound=java.lang.Enum)  # <E>
    @staticmethod
    def allOf(class_: typing.Type[_allOf__E]) -> 'EnumSet'[_allOf__E]: ...
    def clone(self) -> 'EnumSet'[_EnumSet__E]: ...
    _complementOf__E = typing.TypeVar('_complementOf__E', bound=java.lang.Enum)  # <E>
    @staticmethod
    def complementOf(enumSet: 'EnumSet'[_complementOf__E]) -> 'EnumSet'[_complementOf__E]: ...
    _copyOf_0__E = typing.TypeVar('_copyOf_0__E', bound=java.lang.Enum)  # <E>
    _copyOf_1__E = typing.TypeVar('_copyOf_1__E', bound=java.lang.Enum)  # <E>
    @typing.overload
    @staticmethod
    def copyOf(collection: typing.Union[Collection[_copyOf_0__E], typing.Sequence[_copyOf_0__E], typing.Set[_copyOf_0__E]]) -> 'EnumSet'[_copyOf_0__E]: ...
    @typing.overload
    @staticmethod
    def copyOf(enumSet: 'EnumSet'[_copyOf_1__E]) -> 'EnumSet'[_copyOf_1__E]: ...
    _noneOf__E = typing.TypeVar('_noneOf__E', bound=java.lang.Enum)  # <E>
    @staticmethod
    def noneOf(class_: typing.Type[_noneOf__E]) -> 'EnumSet'[_noneOf__E]: ...
    _of_0__E = typing.TypeVar('_of_0__E', bound=java.lang.Enum)  # <E>
    _of_1__E = typing.TypeVar('_of_1__E', bound=java.lang.Enum)  # <E>
    _of_2__E = typing.TypeVar('_of_2__E', bound=java.lang.Enum)  # <E>
    _of_3__E = typing.TypeVar('_of_3__E', bound=java.lang.Enum)  # <E>
    _of_4__E = typing.TypeVar('_of_4__E', bound=java.lang.Enum)  # <E>
    _of_5__E = typing.TypeVar('_of_5__E', bound=java.lang.Enum)  # <E>
    @typing.overload
    @staticmethod
    def of(e: _of_0__E) -> 'EnumSet'[_of_0__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_1__E, e2: _of_1__E) -> 'EnumSet'[_of_1__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_2__E, e2: _of_2__E, e3: _of_2__E) -> 'EnumSet'[_of_2__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_3__E, e2: _of_3__E, e3: _of_3__E, e4: _of_3__E) -> 'EnumSet'[_of_3__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_4__E, e2: _of_4__E, e3: _of_4__E, e4: _of_4__E, e5: _of_4__E) -> 'EnumSet'[_of_4__E]: ...
    @typing.overload
    @staticmethod
    def of(e: _of_5__E, eArray: typing.List[_of_5__E]) -> 'EnumSet'[_of_5__E]: ...
    _range__E = typing.TypeVar('_range__E', bound=java.lang.Enum)  # <E>
    @staticmethod
    def range(e: _range__E, e2: _range__E) -> 'EnumSet'[_range__E]: ...

_HashSet__E = typing.TypeVar('_HashSet__E')  # <E>
class HashSet(AbstractSet[_HashSet__E], Set[_HashSet__E], java.lang.Cloneable, java.io.Serializable, typing.Generic[_HashSet__E]):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, int: int, float: float): ...
    @typing.overload
    def __init__(self, collection: typing.Union[Collection[_HashSet__E], typing.Sequence[_HashSet__E], typing.Set[_HashSet__E]]): ...
    def add(self, e: _HashSet__E) -> bool: ...
    def clear(self) -> None: ...
    def clone(self) -> typing.Any: ...
    def contains(self, object: typing.Any) -> bool: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> Iterator[_HashSet__E]: ...
    def remove(self, object: typing.Any) -> bool: ...
    def size(self) -> int: ...
    def spliterator(self) -> 'Spliterator'[_HashSet__E]: ...

_LinkedHashMap__K = typing.TypeVar('_LinkedHashMap__K')  # <K>
_LinkedHashMap__V = typing.TypeVar('_LinkedHashMap__V')  # <V>
class LinkedHashMap(HashMap[_LinkedHashMap__K, _LinkedHashMap__V], Map[_LinkedHashMap__K, _LinkedHashMap__V], typing.Generic[_LinkedHashMap__K, _LinkedHashMap__V]):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, int: int, float: float): ...
    @typing.overload
    def __init__(self, int: int, float: float, boolean: bool): ...
    @typing.overload
    def __init__(self, map: typing.Union[Map[_LinkedHashMap__K, _LinkedHashMap__V], typing.Mapping[_LinkedHashMap__K, _LinkedHashMap__V]]): ...
    def clear(self) -> None: ...
    def containsValue(self, object: typing.Any) -> bool: ...
    def entrySet(self) -> Set[Map.Entry[_LinkedHashMap__K, _LinkedHashMap__V]]: ...
    def forEach(self, biConsumer: typing.Union[java.util.function.BiConsumer[_LinkedHashMap__K, _LinkedHashMap__V], typing.Callable[[_LinkedHashMap__K, _LinkedHashMap__V], None]]) -> None: ...
    def get(self, object: typing.Any) -> _LinkedHashMap__V: ...
    def getOrDefault(self, object: typing.Any, v: _LinkedHashMap__V) -> _LinkedHashMap__V: ...
    def keySet(self) -> Set[_LinkedHashMap__K]: ...
    def replaceAll(self, biFunction: typing.Union[java.util.function.BiFunction[_LinkedHashMap__K, _LinkedHashMap__V, _LinkedHashMap__V], typing.Callable[[_LinkedHashMap__K, _LinkedHashMap__V], _LinkedHashMap__V]]) -> None: ...
    def values(self) -> Collection[_LinkedHashMap__V]: ...

_NavigableSet__E = typing.TypeVar('_NavigableSet__E')  # <E>
class NavigableSet(SortedSet[_NavigableSet__E], typing.Generic[_NavigableSet__E]):
    def ceiling(self, e: _NavigableSet__E) -> _NavigableSet__E: ...
    def descendingIterator(self) -> Iterator[_NavigableSet__E]: ...
    def descendingSet(self) -> 'NavigableSet'[_NavigableSet__E]: ...
    def equals(self, object: typing.Any) -> bool: ...
    def floor(self, e: _NavigableSet__E) -> _NavigableSet__E: ...
    def hashCode(self) -> int: ...
    @typing.overload
    def headSet(self, e: _NavigableSet__E, boolean: bool) -> 'NavigableSet'[_NavigableSet__E]: ...
    @typing.overload
    def headSet(self, e: _NavigableSet__E) -> SortedSet[_NavigableSet__E]: ...
    def higher(self, e: _NavigableSet__E) -> _NavigableSet__E: ...
    def iterator(self) -> Iterator[_NavigableSet__E]: ...
    def lower(self, e: _NavigableSet__E) -> _NavigableSet__E: ...
    def pollFirst(self) -> _NavigableSet__E: ...
    def pollLast(self) -> _NavigableSet__E: ...
    @typing.overload
    def subSet(self, e: _NavigableSet__E, boolean: bool, e2: _NavigableSet__E, boolean2: bool) -> 'NavigableSet'[_NavigableSet__E]: ...
    @typing.overload
    def subSet(self, e: _NavigableSet__E, e2: _NavigableSet__E) -> SortedSet[_NavigableSet__E]: ...
    @typing.overload
    def tailSet(self, e: _NavigableSet__E, boolean: bool) -> 'NavigableSet'[_NavigableSet__E]: ...
    @typing.overload
    def tailSet(self, e: _NavigableSet__E) -> SortedSet[_NavigableSet__E]: ...

_PriorityQueue__E = typing.TypeVar('_PriorityQueue__E')  # <E>
class PriorityQueue(AbstractQueue[_PriorityQueue__E], java.io.Serializable, typing.Generic[_PriorityQueue__E]):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, int: int, comparator: typing.Union[Comparator[_PriorityQueue__E], typing.Callable[[_PriorityQueue__E, _PriorityQueue__E], int]]): ...
    @typing.overload
    def __init__(self, collection: typing.Union[Collection[_PriorityQueue__E], typing.Sequence[_PriorityQueue__E], typing.Set[_PriorityQueue__E]]): ...
    @typing.overload
    def __init__(self, comparator: typing.Union[Comparator[_PriorityQueue__E], typing.Callable[[_PriorityQueue__E, _PriorityQueue__E], int]]): ...
    @typing.overload
    def __init__(self, priorityQueue: 'PriorityQueue'[_PriorityQueue__E]): ...
    @typing.overload
    def __init__(self, sortedSet: SortedSet[_PriorityQueue__E]): ...
    def add(self, e: _PriorityQueue__E) -> bool: ...
    def clear(self) -> None: ...
    def comparator(self) -> Comparator[_PriorityQueue__E]: ...
    def contains(self, object: typing.Any) -> bool: ...
    def iterator(self) -> Iterator[_PriorityQueue__E]: ...
    def offer(self, e: _PriorityQueue__E) -> bool: ...
    def peek(self) -> _PriorityQueue__E: ...
    def poll(self) -> _PriorityQueue__E: ...
    @typing.overload
    def remove(self, object: typing.Any) -> bool: ...
    @typing.overload
    def remove(self) -> _PriorityQueue__E: ...
    def size(self) -> int: ...
    def spliterator(self) -> 'Spliterator'[_PriorityQueue__E]: ...
    _toArray_1__T = typing.TypeVar('_toArray_1__T')  # <T>
    @typing.overload
    def toArray(self) -> typing.List[typing.Any]: ...
    @typing.overload
    def toArray(self, tArray: typing.List[_toArray_1__T]) -> typing.List[_toArray_1__T]: ...

_TreeMap__K = typing.TypeVar('_TreeMap__K')  # <K>
_TreeMap__V = typing.TypeVar('_TreeMap__V')  # <V>
class TreeMap(AbstractMap[_TreeMap__K, _TreeMap__V], NavigableMap[_TreeMap__K, _TreeMap__V], java.lang.Cloneable, java.io.Serializable, typing.Generic[_TreeMap__K, _TreeMap__V]):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, comparator: typing.Union[Comparator[_TreeMap__K], typing.Callable[[_TreeMap__K, _TreeMap__K], int]]): ...
    @typing.overload
    def __init__(self, map: typing.Union[Map[_TreeMap__K, _TreeMap__V], typing.Mapping[_TreeMap__K, _TreeMap__V]]): ...
    @typing.overload
    def __init__(self, sortedMap: SortedMap[_TreeMap__K, _TreeMap__V]): ...
    def ceilingEntry(self, k: _TreeMap__K) -> Map.Entry[_TreeMap__K, _TreeMap__V]: ...
    def ceilingKey(self, k: _TreeMap__K) -> _TreeMap__K: ...
    def clear(self) -> None: ...
    def clone(self) -> typing.Any: ...
    def comparator(self) -> Comparator[_TreeMap__K]: ...
    def containsKey(self, object: typing.Any) -> bool: ...
    def containsValue(self, object: typing.Any) -> bool: ...
    def descendingKeySet(self) -> NavigableSet[_TreeMap__K]: ...
    def descendingMap(self) -> NavigableMap[_TreeMap__K, _TreeMap__V]: ...
    def entrySet(self) -> Set[Map.Entry[_TreeMap__K, _TreeMap__V]]: ...
    def firstEntry(self) -> Map.Entry[_TreeMap__K, _TreeMap__V]: ...
    def firstKey(self) -> _TreeMap__K: ...
    def floorEntry(self, k: _TreeMap__K) -> Map.Entry[_TreeMap__K, _TreeMap__V]: ...
    def floorKey(self, k: _TreeMap__K) -> _TreeMap__K: ...
    def forEach(self, biConsumer: typing.Union[java.util.function.BiConsumer[_TreeMap__K, _TreeMap__V], typing.Callable[[_TreeMap__K, _TreeMap__V], None]]) -> None: ...
    def get(self, object: typing.Any) -> _TreeMap__V: ...
    @typing.overload
    def headMap(self, k: _TreeMap__K, boolean: bool) -> NavigableMap[_TreeMap__K, _TreeMap__V]: ...
    @typing.overload
    def headMap(self, k: _TreeMap__K) -> SortedMap[_TreeMap__K, _TreeMap__V]: ...
    def higherEntry(self, k: _TreeMap__K) -> Map.Entry[_TreeMap__K, _TreeMap__V]: ...
    def higherKey(self, k: _TreeMap__K) -> _TreeMap__K: ...
    def keySet(self) -> Set[_TreeMap__K]: ...
    def lastEntry(self) -> Map.Entry[_TreeMap__K, _TreeMap__V]: ...
    def lastKey(self) -> _TreeMap__K: ...
    def lowerEntry(self, k: _TreeMap__K) -> Map.Entry[_TreeMap__K, _TreeMap__V]: ...
    def lowerKey(self, k: _TreeMap__K) -> _TreeMap__K: ...
    def navigableKeySet(self) -> NavigableSet[_TreeMap__K]: ...
    def pollFirstEntry(self) -> Map.Entry[_TreeMap__K, _TreeMap__V]: ...
    def pollLastEntry(self) -> Map.Entry[_TreeMap__K, _TreeMap__V]: ...
    def put(self, k: _TreeMap__K, v: _TreeMap__V) -> _TreeMap__V: ...
    def putAll(self, map: typing.Union[Map[_TreeMap__K, _TreeMap__V], typing.Mapping[_TreeMap__K, _TreeMap__V]]) -> None: ...
    @typing.overload
    def remove(self, object: typing.Any, object2: typing.Any) -> bool: ...
    @typing.overload
    def remove(self, object: typing.Any) -> _TreeMap__V: ...
    @typing.overload
    def replace(self, k: _TreeMap__K, v: _TreeMap__V, v2: _TreeMap__V) -> bool: ...
    @typing.overload
    def replace(self, k: _TreeMap__K, v: _TreeMap__V) -> _TreeMap__V: ...
    def replaceAll(self, biFunction: typing.Union[java.util.function.BiFunction[_TreeMap__K, _TreeMap__V, _TreeMap__V], typing.Callable[[_TreeMap__K, _TreeMap__V], _TreeMap__V]]) -> None: ...
    def size(self) -> int: ...
    @typing.overload
    def subMap(self, k: _TreeMap__K, boolean: bool, k2: _TreeMap__K, boolean2: bool) -> NavigableMap[_TreeMap__K, _TreeMap__V]: ...
    @typing.overload
    def subMap(self, k: _TreeMap__K, k2: _TreeMap__K) -> SortedMap[_TreeMap__K, _TreeMap__V]: ...
    @typing.overload
    def tailMap(self, k: _TreeMap__K, boolean: bool) -> NavigableMap[_TreeMap__K, _TreeMap__V]: ...
    @typing.overload
    def tailMap(self, k: _TreeMap__K) -> SortedMap[_TreeMap__K, _TreeMap__V]: ...
    def values(self) -> Collection[_TreeMap__V]: ...

_Vector__E = typing.TypeVar('_Vector__E')  # <E>
class Vector(AbstractList[_Vector__E], List[_Vector__E], RandomAccess, java.lang.Cloneable, java.io.Serializable, typing.Generic[_Vector__E]):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, int: int, int2: int): ...
    @typing.overload
    def __init__(self, collection: typing.Union[Collection[_Vector__E], typing.Sequence[_Vector__E], typing.Set[_Vector__E]]): ...
    @typing.overload
    def add(self, e: _Vector__E) -> bool: ...
    @typing.overload
    def add(self, int: int, e: _Vector__E) -> None: ...
    @typing.overload
    def addAll(self, int: int, collection: typing.Union[Collection[_Vector__E], typing.Sequence[_Vector__E], typing.Set[_Vector__E]]) -> bool: ...
    @typing.overload
    def addAll(self, collection: typing.Union[Collection[_Vector__E], typing.Sequence[_Vector__E], typing.Set[_Vector__E]]) -> bool: ...
    def addElement(self, e: _Vector__E) -> None: ...
    def capacity(self) -> int: ...
    def clear(self) -> None: ...
    def clone(self) -> typing.Any: ...
    def contains(self, object: typing.Any) -> bool: ...
    def containsAll(self, collection: typing.Union[Collection[typing.Any], typing.Sequence[typing.Any], typing.Set[typing.Any]]) -> bool: ...
    def copyInto(self, objectArray: typing.List[typing.Any]) -> None: ...
    def elementAt(self, int: int) -> _Vector__E: ...
    def elements(self) -> Enumeration[_Vector__E]: ...
    def ensureCapacity(self, int: int) -> None: ...
    def equals(self, object: typing.Any) -> bool: ...
    def firstElement(self) -> _Vector__E: ...
    def forEach(self, consumer: typing.Union[java.util.function.Consumer[_Vector__E], typing.Callable[[_Vector__E], None]]) -> None: ...
    def get(self, int: int) -> _Vector__E: ...
    def hashCode(self) -> int: ...
    @typing.overload
    def indexOf(self, object: typing.Any) -> int: ...
    @typing.overload
    def indexOf(self, object: typing.Any, int: int) -> int: ...
    def insertElementAt(self, e: _Vector__E, int: int) -> None: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> Iterator[_Vector__E]: ...
    def lastElement(self) -> _Vector__E: ...
    @typing.overload
    def lastIndexOf(self, object: typing.Any) -> int: ...
    @typing.overload
    def lastIndexOf(self, object: typing.Any, int: int) -> int: ...
    @typing.overload
    def listIterator(self) -> ListIterator[_Vector__E]: ...
    @typing.overload
    def listIterator(self, int: int) -> ListIterator[_Vector__E]: ...
    def removeAll(self, collection: typing.Union[Collection[typing.Any], typing.Sequence[typing.Any], typing.Set[typing.Any]]) -> bool: ...
    def removeAllElements(self) -> None: ...
    def removeElement(self, object: typing.Any) -> bool: ...
    def removeElementAt(self, int: int) -> None: ...
    def removeIf(self, predicate: typing.Union[java.util.function.Predicate[_Vector__E], typing.Callable[[_Vector__E], bool]]) -> bool: ...
    def replaceAll(self, unaryOperator: typing.Union[java.util.function.UnaryOperator[_Vector__E], typing.Callable]) -> None: ...
    def retainAll(self, collection: typing.Union[Collection[typing.Any], typing.Sequence[typing.Any], typing.Set[typing.Any]]) -> bool: ...
    def set(self, int: int, e: _Vector__E) -> _Vector__E: ...
    def setElementAt(self, e: _Vector__E, int: int) -> None: ...
    def setSize(self, int: int) -> None: ...
    def size(self) -> int: ...
    def sort(self, comparator: typing.Union[Comparator[_Vector__E], typing.Callable[[_Vector__E, _Vector__E], int]]) -> None: ...
    def spliterator(self) -> 'Spliterator'[_Vector__E]: ...
    def subList(self, int: int, int2: int) -> List[_Vector__E]: ...
    _toArray_1__T = typing.TypeVar('_toArray_1__T')  # <T>
    @typing.overload
    def toArray(self) -> typing.List[typing.Any]: ...
    @typing.overload
    def toArray(self, tArray: typing.List[_toArray_1__T]) -> typing.List[_toArray_1__T]: ...
    def toString(self) -> str: ...
    def trimToSize(self) -> None: ...

_LinkedHashSet__E = typing.TypeVar('_LinkedHashSet__E')  # <E>
class LinkedHashSet(HashSet[_LinkedHashSet__E], Set[_LinkedHashSet__E], java.lang.Cloneable, java.io.Serializable, typing.Generic[_LinkedHashSet__E]):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, int: int, float: float): ...
    @typing.overload
    def __init__(self, collection: typing.Union[Collection[_LinkedHashSet__E], typing.Sequence[_LinkedHashSet__E], typing.Set[_LinkedHashSet__E]]): ...
    def spliterator(self) -> 'Spliterator'[_LinkedHashSet__E]: ...

_LinkedList__E = typing.TypeVar('_LinkedList__E')  # <E>
class LinkedList(AbstractSequentialList[_LinkedList__E], List[_LinkedList__E], Deque[_LinkedList__E], java.lang.Cloneable, java.io.Serializable, typing.Generic[_LinkedList__E]):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, collection: typing.Union[Collection[_LinkedList__E], typing.Sequence[_LinkedList__E], typing.Set[_LinkedList__E]]): ...
    @typing.overload
    def add(self, e: _LinkedList__E) -> bool: ...
    @typing.overload
    def add(self, int: int, e: _LinkedList__E) -> None: ...
    @typing.overload
    def addAll(self, int: int, collection: typing.Union[Collection[_LinkedList__E], typing.Sequence[_LinkedList__E], typing.Set[_LinkedList__E]]) -> bool: ...
    @typing.overload
    def addAll(self, collection: typing.Union[Collection[_LinkedList__E], typing.Sequence[_LinkedList__E], typing.Set[_LinkedList__E]]) -> bool: ...
    def addFirst(self, e: _LinkedList__E) -> None: ...
    def addLast(self, e: _LinkedList__E) -> None: ...
    def clear(self) -> None: ...
    def clone(self) -> typing.Any: ...
    def contains(self, object: typing.Any) -> bool: ...
    def descendingIterator(self) -> Iterator[_LinkedList__E]: ...
    def element(self) -> _LinkedList__E: ...
    def get(self, int: int) -> _LinkedList__E: ...
    def getFirst(self) -> _LinkedList__E: ...
    def getLast(self) -> _LinkedList__E: ...
    def indexOf(self, object: typing.Any) -> int: ...
    def lastIndexOf(self, object: typing.Any) -> int: ...
    @typing.overload
    def listIterator(self) -> ListIterator[_LinkedList__E]: ...
    @typing.overload
    def listIterator(self, int: int) -> ListIterator[_LinkedList__E]: ...
    def offer(self, e: _LinkedList__E) -> bool: ...
    def offerFirst(self, e: _LinkedList__E) -> bool: ...
    def offerLast(self, e: _LinkedList__E) -> bool: ...
    def peek(self) -> _LinkedList__E: ...
    def peekFirst(self) -> _LinkedList__E: ...
    def peekLast(self) -> _LinkedList__E: ...
    def poll(self) -> _LinkedList__E: ...
    def pollFirst(self) -> _LinkedList__E: ...
    def pollLast(self) -> _LinkedList__E: ...
    def pop(self) -> _LinkedList__E: ...
    def push(self, e: _LinkedList__E) -> None: ...
    def removeFirst(self) -> _LinkedList__E: ...
    def removeFirstOccurrence(self, object: typing.Any) -> bool: ...
    def removeLast(self) -> _LinkedList__E: ...
    def removeLastOccurrence(self, object: typing.Any) -> bool: ...
    def set(self, int: int, e: _LinkedList__E) -> _LinkedList__E: ...
    def size(self) -> int: ...
    def spliterator(self) -> 'Spliterator'[_LinkedList__E]: ...
    _toArray_1__T = typing.TypeVar('_toArray_1__T')  # <T>
    @typing.overload
    def toArray(self) -> typing.List[typing.Any]: ...
    @typing.overload
    def toArray(self, tArray: typing.List[_toArray_1__T]) -> typing.List[_toArray_1__T]: ...

_Stack__E = typing.TypeVar('_Stack__E')  # <E>
class Stack(Vector[_Stack__E], typing.Generic[_Stack__E]):
    def __init__(self): ...
    def empty(self) -> bool: ...
    def peek(self) -> _Stack__E: ...
    def pop(self) -> _Stack__E: ...
    def push(self, e: _Stack__E) -> _Stack__E: ...
    def search(self, object: typing.Any) -> int: ...

_TreeSet__E = typing.TypeVar('_TreeSet__E')  # <E>
class TreeSet(AbstractSet[_TreeSet__E], NavigableSet[_TreeSet__E], java.lang.Cloneable, java.io.Serializable, typing.Generic[_TreeSet__E]):
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, collection: typing.Union[Collection[_TreeSet__E], typing.Sequence[_TreeSet__E], typing.Set[_TreeSet__E]]): ...
    @typing.overload
    def __init__(self, comparator: typing.Union[Comparator[_TreeSet__E], typing.Callable[[_TreeSet__E, _TreeSet__E], int]]): ...
    @typing.overload
    def __init__(self, sortedSet: SortedSet[_TreeSet__E]): ...
    def add(self, e: _TreeSet__E) -> bool: ...
    def addAll(self, collection: typing.Union[Collection[_TreeSet__E], typing.Sequence[_TreeSet__E], typing.Set[_TreeSet__E]]) -> bool: ...
    def ceiling(self, e: _TreeSet__E) -> _TreeSet__E: ...
    def clear(self) -> None: ...
    def clone(self) -> typing.Any: ...
    def comparator(self) -> Comparator[_TreeSet__E]: ...
    def contains(self, object: typing.Any) -> bool: ...
    def descendingIterator(self) -> Iterator[_TreeSet__E]: ...
    def descendingSet(self) -> NavigableSet[_TreeSet__E]: ...
    def first(self) -> _TreeSet__E: ...
    def floor(self, e: _TreeSet__E) -> _TreeSet__E: ...
    @typing.overload
    def headSet(self, e: _TreeSet__E, boolean: bool) -> NavigableSet[_TreeSet__E]: ...
    @typing.overload
    def headSet(self, e: _TreeSet__E) -> SortedSet[_TreeSet__E]: ...
    def higher(self, e: _TreeSet__E) -> _TreeSet__E: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> Iterator[_TreeSet__E]: ...
    def last(self) -> _TreeSet__E: ...
    def lower(self, e: _TreeSet__E) -> _TreeSet__E: ...
    def pollFirst(self) -> _TreeSet__E: ...
    def pollLast(self) -> _TreeSet__E: ...
    def remove(self, object: typing.Any) -> bool: ...
    def size(self) -> int: ...
    def spliterator(self) -> 'Spliterator'[_TreeSet__E]: ...
    @typing.overload
    def subSet(self, e: _TreeSet__E, boolean: bool, e2: _TreeSet__E, boolean2: bool) -> NavigableSet[_TreeSet__E]: ...
    @typing.overload
    def subSet(self, e: _TreeSet__E, e2: _TreeSet__E) -> SortedSet[_TreeSet__E]: ...
    @typing.overload
    def tailSet(self, e: _TreeSet__E, boolean: bool) -> NavigableSet[_TreeSet__E]: ...
    @typing.overload
    def tailSet(self, e: _TreeSet__E) -> SortedSet[_TreeSet__E]: ...

_PrimitiveIterator__T = typing.TypeVar('_PrimitiveIterator__T')  # <T>
_PrimitiveIterator__T_CONS = typing.TypeVar('_PrimitiveIterator__T_CONS')  # <T_CONS>
class PrimitiveIterator(Iterator[_PrimitiveIterator__T], typing.Generic[_PrimitiveIterator__T, _PrimitiveIterator__T_CONS]):
    @typing.overload
    def forEachRemaining(self, t_CONS: _PrimitiveIterator__T_CONS) -> None: ...
    @typing.overload
    def forEachRemaining(self, consumer: typing.Union[java.util.function.Consumer[typing.Any], typing.Callable[[typing.Any], None]]) -> None: ...
    class OfDouble(java.util.PrimitiveIterator[float, java.util.function.DoubleConsumer]):
        @typing.overload
        def forEachRemaining(self, consumer: typing.Union[java.util.function.Consumer[float], typing.Callable[[float], None]]) -> None: ...
        @typing.overload
        def forEachRemaining(self, doubleConsumer: typing.Union[java.util.function.DoubleConsumer, typing.Callable]) -> None: ...
        def next(self) -> float: ...
        def nextDouble(self) -> float: ...
    class OfInt(java.util.PrimitiveIterator[int, java.util.function.IntConsumer]):
        @typing.overload
        def forEachRemaining(self, consumer: typing.Union[java.util.function.Consumer[int], typing.Callable[[int], None]]) -> None: ...
        @typing.overload
        def forEachRemaining(self, intConsumer: typing.Union[java.util.function.IntConsumer, typing.Callable]) -> None: ...
        def next(self) -> int: ...
        def nextInt(self) -> int: ...
    class OfLong(java.util.PrimitiveIterator[int, java.util.function.LongConsumer]):
        @typing.overload
        def forEachRemaining(self, consumer: typing.Union[java.util.function.Consumer[int], typing.Callable[[int], None]]) -> None: ...
        @typing.overload
        def forEachRemaining(self, longConsumer: typing.Union[java.util.function.LongConsumer, typing.Callable]) -> None: ...
        def next(self) -> int: ...
        def nextLong(self) -> int: ...

_Spliterator__OfPrimitive__T = typing.TypeVar('_Spliterator__OfPrimitive__T')  # <T>
_Spliterator__OfPrimitive__T_CONS = typing.TypeVar('_Spliterator__OfPrimitive__T_CONS')  # <T_CONS>
_Spliterator__OfPrimitive__T_SPLITR = typing.TypeVar('_Spliterator__OfPrimitive__T_SPLITR', bound='Spliterator.OfPrimitive')  # <T_SPLITR>
_Spliterator__T = typing.TypeVar('_Spliterator__T')  # <T>
class Spliterator(typing.Generic[_Spliterator__T]):
    ORDERED: typing.ClassVar[int] = ...
    DISTINCT: typing.ClassVar[int] = ...
    SORTED: typing.ClassVar[int] = ...
    SIZED: typing.ClassVar[int] = ...
    NONNULL: typing.ClassVar[int] = ...
    IMMUTABLE: typing.ClassVar[int] = ...
    CONCURRENT: typing.ClassVar[int] = ...
    SUBSIZED: typing.ClassVar[int] = ...
    def characteristics(self) -> int: ...
    def estimateSize(self) -> int: ...
    def forEachRemaining(self, consumer: typing.Union[java.util.function.Consumer[_Spliterator__T], typing.Callable[[_Spliterator__T], None]]) -> None: ...
    def getComparator(self) -> Comparator[_Spliterator__T]: ...
    def getExactSizeIfKnown(self) -> int: ...
    def hasCharacteristics(self, int: int) -> bool: ...
    def tryAdvance(self, consumer: typing.Union[java.util.function.Consumer[_Spliterator__T], typing.Callable[[_Spliterator__T], None]]) -> bool: ...
    def trySplit(self) -> 'Spliterator'[_Spliterator__T]: ...
    class OfDouble(java.util.Spliterator.OfPrimitive[float, java.util.function.DoubleConsumer, 'Spliterator.OfDouble']):
        @typing.overload
        def forEachRemaining(self, consumer: typing.Union[java.util.function.Consumer[float], typing.Callable[[float], None]]) -> None: ...
        @typing.overload
        def forEachRemaining(self, doubleConsumer: typing.Union[java.util.function.DoubleConsumer, typing.Callable]) -> None: ...
        @typing.overload
        def tryAdvance(self, doubleConsumer: typing.Union[java.util.function.DoubleConsumer, typing.Callable]) -> bool: ...
        @typing.overload
        def tryAdvance(self, consumer: typing.Union[java.util.function.Consumer[float], typing.Callable[[float], None]]) -> bool: ...
        def trySplit(self) -> 'Spliterator.OfDouble': ...
    class OfInt(java.util.Spliterator.OfPrimitive[int, java.util.function.IntConsumer, 'Spliterator.OfInt']):
        @typing.overload
        def forEachRemaining(self, consumer: typing.Union[java.util.function.Consumer[int], typing.Callable[[int], None]]) -> None: ...
        @typing.overload
        def forEachRemaining(self, intConsumer: typing.Union[java.util.function.IntConsumer, typing.Callable]) -> None: ...
        @typing.overload
        def tryAdvance(self, intConsumer: typing.Union[java.util.function.IntConsumer, typing.Callable]) -> bool: ...
        @typing.overload
        def tryAdvance(self, consumer: typing.Union[java.util.function.Consumer[int], typing.Callable[[int], None]]) -> bool: ...
        def trySplit(self) -> 'Spliterator.OfInt': ...
    class OfLong(java.util.Spliterator.OfPrimitive[int, java.util.function.LongConsumer, 'Spliterator.OfLong']):
        @typing.overload
        def forEachRemaining(self, consumer: typing.Union[java.util.function.Consumer[int], typing.Callable[[int], None]]) -> None: ...
        @typing.overload
        def forEachRemaining(self, longConsumer: typing.Union[java.util.function.LongConsumer, typing.Callable]) -> None: ...
        @typing.overload
        def tryAdvance(self, longConsumer: typing.Union[java.util.function.LongConsumer, typing.Callable]) -> bool: ...
        @typing.overload
        def tryAdvance(self, consumer: typing.Union[java.util.function.Consumer[int], typing.Callable[[int], None]]) -> bool: ...
        def trySplit(self) -> 'Spliterator.OfLong': ...
    class OfPrimitive(java.util.Spliterator[_Spliterator__OfPrimitive__T], typing.Generic[_Spliterator__OfPrimitive__T, _Spliterator__OfPrimitive__T_CONS, _Spliterator__OfPrimitive__T_SPLITR]):
        @typing.overload
        def forEachRemaining(self, t_CONS: _Spliterator__OfPrimitive__T_CONS) -> None: ...
        @typing.overload
        def forEachRemaining(self, consumer: typing.Union[java.util.function.Consumer[_Spliterator__OfPrimitive__T], typing.Callable[[_Spliterator__OfPrimitive__T], None]]) -> None: ...
        @typing.overload
        def tryAdvance(self, t_CONS: _Spliterator__OfPrimitive__T_CONS) -> bool: ...
        @typing.overload
        def tryAdvance(self, consumer: typing.Union[java.util.function.Consumer[_Spliterator__OfPrimitive__T], typing.Callable[[_Spliterator__OfPrimitive__T], None]]) -> bool: ...
        def trySplit(self) -> _Spliterator__OfPrimitive__T_SPLITR: ...

_Spliterators__AbstractSpliterator__T = typing.TypeVar('_Spliterators__AbstractSpliterator__T')  # <T>
class Spliterators:
    @staticmethod
    def emptyDoubleSpliterator() -> Spliterator.OfDouble: ...
    @staticmethod
    def emptyIntSpliterator() -> Spliterator.OfInt: ...
    @staticmethod
    def emptyLongSpliterator() -> Spliterator.OfLong: ...
    _emptySpliterator__T = typing.TypeVar('_emptySpliterator__T')  # <T>
    @staticmethod
    def emptySpliterator() -> Spliterator[_emptySpliterator__T]: ...
    _iterator_0__T = typing.TypeVar('_iterator_0__T')  # <T>
    @typing.overload
    @staticmethod
    def iterator(spliterator: Spliterator[_iterator_0__T]) -> Iterator[_iterator_0__T]: ...
    @typing.overload
    @staticmethod
    def iterator(ofDouble: Spliterator.OfDouble) -> PrimitiveIterator.OfDouble: ...
    @typing.overload
    @staticmethod
    def iterator(ofInt: Spliterator.OfInt) -> PrimitiveIterator.OfInt: ...
    @typing.overload
    @staticmethod
    def iterator(ofLong: Spliterator.OfLong) -> PrimitiveIterator.OfLong: ...
    _spliterator_0__T = typing.TypeVar('_spliterator_0__T')  # <T>
    _spliterator_1__T = typing.TypeVar('_spliterator_1__T')  # <T>
    _spliterator_2__T = typing.TypeVar('_spliterator_2__T')  # <T>
    _spliterator_3__T = typing.TypeVar('_spliterator_3__T')  # <T>
    @typing.overload
    @staticmethod
    def spliterator(objectArray: typing.List[typing.Any], int: int) -> Spliterator[_spliterator_0__T]: ...
    @typing.overload
    @staticmethod
    def spliterator(objectArray: typing.List[typing.Any], int: int, int2: int, int3: int) -> Spliterator[_spliterator_1__T]: ...
    @typing.overload
    @staticmethod
    def spliterator(collection: typing.Union[Collection[_spliterator_2__T], typing.Sequence[_spliterator_2__T], typing.Set[_spliterator_2__T]], int: int) -> Spliterator[_spliterator_2__T]: ...
    @typing.overload
    @staticmethod
    def spliterator(iterator: Iterator[_spliterator_3__T], long: int, int: int) -> Spliterator[_spliterator_3__T]: ...
    @typing.overload
    @staticmethod
    def spliterator(doubleArray: typing.List[float], int: int) -> Spliterator.OfDouble: ...
    @typing.overload
    @staticmethod
    def spliterator(doubleArray: typing.List[float], int: int, int2: int, int3: int) -> Spliterator.OfDouble: ...
    @typing.overload
    @staticmethod
    def spliterator(ofDouble: PrimitiveIterator.OfDouble, long: int, int: int) -> Spliterator.OfDouble: ...
    @typing.overload
    @staticmethod
    def spliterator(intArray: typing.List[int], int2: int) -> Spliterator.OfInt: ...
    @typing.overload
    @staticmethod
    def spliterator(intArray: typing.List[int], int2: int, int3: int, int4: int) -> Spliterator.OfInt: ...
    @typing.overload
    @staticmethod
    def spliterator(ofInt: PrimitiveIterator.OfInt, long: int, int: int) -> Spliterator.OfInt: ...
    @typing.overload
    @staticmethod
    def spliterator(ofLong: PrimitiveIterator.OfLong, long: int, int: int) -> Spliterator.OfLong: ...
    @typing.overload
    @staticmethod
    def spliterator(longArray: typing.List[int], int: int) -> Spliterator.OfLong: ...
    @typing.overload
    @staticmethod
    def spliterator(longArray: typing.List[int], int: int, int2: int, int3: int) -> Spliterator.OfLong: ...
    _spliteratorUnknownSize_0__T = typing.TypeVar('_spliteratorUnknownSize_0__T')  # <T>
    @typing.overload
    @staticmethod
    def spliteratorUnknownSize(iterator: Iterator[_spliteratorUnknownSize_0__T], int: int) -> Spliterator[_spliteratorUnknownSize_0__T]: ...
    @typing.overload
    @staticmethod
    def spliteratorUnknownSize(ofDouble: PrimitiveIterator.OfDouble, int: int) -> Spliterator.OfDouble: ...
    @typing.overload
    @staticmethod
    def spliteratorUnknownSize(ofInt: PrimitiveIterator.OfInt, int: int) -> Spliterator.OfInt: ...
    @typing.overload
    @staticmethod
    def spliteratorUnknownSize(ofLong: PrimitiveIterator.OfLong, int: int) -> Spliterator.OfLong: ...
    class AbstractDoubleSpliterator(Spliterator.OfDouble):
        def characteristics(self) -> int: ...
        def estimateSize(self) -> int: ...
        def trySplit(self) -> Spliterator.OfDouble: ...
    class AbstractIntSpliterator(Spliterator.OfInt):
        def characteristics(self) -> int: ...
        def estimateSize(self) -> int: ...
        def trySplit(self) -> Spliterator.OfInt: ...
    class AbstractLongSpliterator(Spliterator.OfLong):
        def characteristics(self) -> int: ...
        def estimateSize(self) -> int: ...
        def trySplit(self) -> Spliterator.OfLong: ...
    class AbstractSpliterator(Spliterator[_Spliterators__AbstractSpliterator__T], typing.Generic[_Spliterators__AbstractSpliterator__T]):
        def characteristics(self) -> int: ...
        def estimateSize(self) -> int: ...
        def trySplit(self) -> Spliterator[_Spliterators__AbstractSpliterator__T]: ...


class __module_protocol__(typing.Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("java.util")``.

    AbstractCollection: typing.Type[AbstractCollection]
    AbstractList: typing.Type[AbstractList]
    AbstractMap: typing.Type[AbstractMap]
    AbstractQueue: typing.Type[AbstractQueue]
    AbstractSequentialList: typing.Type[AbstractSequentialList]
    AbstractSet: typing.Type[AbstractSet]
    ArrayDeque: typing.Type[ArrayDeque]
    ArrayList: typing.Type[ArrayList]
    Arrays: typing.Type[Arrays]
    Base64: typing.Type[Base64]
    BitSet: typing.Type[BitSet]
    Calendar: typing.Type[Calendar]
    Collection: typing.Type[Collection]
    Collections: typing.Type[Collections]
    Comparator: typing.Type[Comparator]
    ConcurrentModificationException: typing.Type[ConcurrentModificationException]
    Currency: typing.Type[Currency]
    Date: typing.Type[Date]
    Deque: typing.Type[Deque]
    Dictionary: typing.Type[Dictionary]
    DoubleSummaryStatistics: typing.Type[DoubleSummaryStatistics]
    DuplicateFormatFlagsException: typing.Type[DuplicateFormatFlagsException]
    EmptyStackException: typing.Type[EmptyStackException]
    EnumMap: typing.Type[EnumMap]
    EnumSet: typing.Type[EnumSet]
    Enumeration: typing.Type[Enumeration]
    EventListener: typing.Type[EventListener]
    EventListenerProxy: typing.Type[EventListenerProxy]
    EventObject: typing.Type[EventObject]
    FormatFlagsConversionMismatchException: typing.Type[FormatFlagsConversionMismatchException]
    Formattable: typing.Type[Formattable]
    FormattableFlags: typing.Type[FormattableFlags]
    Formatter: typing.Type[Formatter]
    FormatterClosedException: typing.Type[FormatterClosedException]
    GregorianCalendar: typing.Type[GregorianCalendar]
    HashMap: typing.Type[HashMap]
    HashSet: typing.Type[HashSet]
    Hashtable: typing.Type[Hashtable]
    IdentityHashMap: typing.Type[IdentityHashMap]
    IllegalFormatCodePointException: typing.Type[IllegalFormatCodePointException]
    IllegalFormatConversionException: typing.Type[IllegalFormatConversionException]
    IllegalFormatException: typing.Type[IllegalFormatException]
    IllegalFormatFlagsException: typing.Type[IllegalFormatFlagsException]
    IllegalFormatPrecisionException: typing.Type[IllegalFormatPrecisionException]
    IllegalFormatWidthException: typing.Type[IllegalFormatWidthException]
    IllformedLocaleException: typing.Type[IllformedLocaleException]
    InputMismatchException: typing.Type[InputMismatchException]
    IntSummaryStatistics: typing.Type[IntSummaryStatistics]
    InvalidPropertiesFormatException: typing.Type[InvalidPropertiesFormatException]
    Iterator: typing.Type[Iterator]
    LinkedHashMap: typing.Type[LinkedHashMap]
    LinkedHashSet: typing.Type[LinkedHashSet]
    LinkedList: typing.Type[LinkedList]
    List: typing.Type[List]
    ListIterator: typing.Type[ListIterator]
    ListResourceBundle: typing.Type[ListResourceBundle]
    Locale: typing.Type[Locale]
    LongSummaryStatistics: typing.Type[LongSummaryStatistics]
    Map: typing.Type[Map]
    MissingFormatArgumentException: typing.Type[MissingFormatArgumentException]
    MissingFormatWidthException: typing.Type[MissingFormatWidthException]
    MissingResourceException: typing.Type[MissingResourceException]
    NavigableMap: typing.Type[NavigableMap]
    NavigableSet: typing.Type[NavigableSet]
    NoSuchElementException: typing.Type[NoSuchElementException]
    Objects: typing.Type[Objects]
    Observable: typing.Type[Observable]
    Observer: typing.Type[Observer]
    Optional: typing.Type[Optional]
    OptionalDouble: typing.Type[OptionalDouble]
    OptionalInt: typing.Type[OptionalInt]
    OptionalLong: typing.Type[OptionalLong]
    PrimitiveIterator: typing.Type[PrimitiveIterator]
    PriorityQueue: typing.Type[PriorityQueue]
    Properties: typing.Type[Properties]
    PropertyPermission: typing.Type[PropertyPermission]
    PropertyResourceBundle: typing.Type[PropertyResourceBundle]
    Queue: typing.Type[Queue]
    Random: typing.Type[Random]
    RandomAccess: typing.Type[RandomAccess]
    ResourceBundle: typing.Type[ResourceBundle]
    Scanner: typing.Type[Scanner]
    ServiceConfigurationError: typing.Type[ServiceConfigurationError]
    ServiceLoader: typing.Type[ServiceLoader]
    Set: typing.Type[Set]
    SimpleTimeZone: typing.Type[SimpleTimeZone]
    SortedMap: typing.Type[SortedMap]
    SortedSet: typing.Type[SortedSet]
    Spliterator: typing.Type[Spliterator]
    Spliterators: typing.Type[Spliterators]
    SplittableRandom: typing.Type[SplittableRandom]
    Stack: typing.Type[Stack]
    StringJoiner: typing.Type[StringJoiner]
    StringTokenizer: typing.Type[StringTokenizer]
    TimeZone: typing.Type[TimeZone]
    Timer: typing.Type[Timer]
    TimerTask: typing.Type[TimerTask]
    TooManyListenersException: typing.Type[TooManyListenersException]
    TreeMap: typing.Type[TreeMap]
    TreeSet: typing.Type[TreeSet]
    UUID: typing.Type[UUID]
    UnknownFormatConversionException: typing.Type[UnknownFormatConversionException]
    UnknownFormatFlagsException: typing.Type[UnknownFormatFlagsException]
    Vector: typing.Type[Vector]
    WeakHashMap: typing.Type[WeakHashMap]
    concurrent: java.util.concurrent.__module_protocol__
    function: java.util.function.__module_protocol__
    jar: java.util.jar.__module_protocol__
    logging: java.util.logging.__module_protocol__
    prefs: java.util.prefs.__module_protocol__
    regex: java.util.regex.__module_protocol__
    spi: java.util.spi.__module_protocol__
    stream: java.util.stream.__module_protocol__
    zip: java.util.zip.__module_protocol__
